   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB11:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2017 Jun Wako, Jack Humbert
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #if defined(__AVR__)
  20:quantum/matrix.c **** #include <avr/io.h>
  21:quantum/matrix.c **** #endif
  22:quantum/matrix.c **** #include "wait.h"
  23:quantum/matrix.c **** #include "print.h"
  24:quantum/matrix.c **** #include "debug.h"
  25:quantum/matrix.c **** #include "util.h"
  26:quantum/matrix.c **** #include "matrix.h"
  27:quantum/matrix.c **** #include "timer.h"
  28:quantum/matrix.c **** 
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  31:quantum/matrix.c **** 
  32:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  33:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  34:quantum/matrix.c **** #endif
  35:quantum/matrix.c **** 
  36:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  37:quantum/matrix.c ****     static uint16_t debouncing_time;
  38:quantum/matrix.c ****     static bool debouncing = false;
  39:quantum/matrix.c **** #endif
  40:quantum/matrix.c **** 
  41:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  42:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  43:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  44:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  45:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  46:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  47:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  48:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  49:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  50:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  51:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  52:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  53:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  54:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  55:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  56:quantum/matrix.c **** #endif
  57:quantum/matrix.c **** 
  58:quantum/matrix.c **** #ifdef MATRIX_MASKED
  59:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  60:quantum/matrix.c **** #endif
  61:quantum/matrix.c **** 
  62:quantum/matrix.c **** #if (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** #endif
  66:quantum/matrix.c **** 
  67:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  68:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  69:quantum/matrix.c **** 
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	/* epilogue start */
 109:quantum/matrix.c **** }
  23               		.loc 1 109 0
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE11:
  28               		.set	matrix_init_user.localalias.0,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB9:
  98:quantum/matrix.c ****     matrix_init_user();
  34               		.loc 1 98 0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  99:quantum/matrix.c **** }
  40               		.loc 1 99 0
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE9:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB7:
  88:quantum/matrix.c ****     matrix_init_kb();
  51               		.loc 1 88 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  89:quantum/matrix.c **** }
  57               		.loc 1 89 0
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE7:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB28:
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  73               	/* epilogue start */
  74 0000 0895      		ret
  75               		.cfi_endproc
  76               	.LFE28:
  78               		.section	.text.matrix_scan_kb,"ax",@progbits
  79               		.weak	matrix_scan_kb
  81               	matrix_scan_kb:
  82               	.LFB10:
 103:quantum/matrix.c ****     matrix_scan_user();
  83               		.loc 1 103 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 104:quantum/matrix.c **** }
  89               		.loc 1 104 0
  90 0000 0C94 0000 		jmp matrix_scan_user
  91               	.LVL2:
  92               		.cfi_endproc
  93               	.LFE10:
  95               		.section	.text.matrix_scan_quantum,"ax",@progbits
  96               		.weak	matrix_scan_quantum
  98               	matrix_scan_quantum:
  99               	.LFB8:
  93:quantum/matrix.c ****     matrix_scan_kb();
 100               		.loc 1 93 0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  94:quantum/matrix.c **** }
 106               		.loc 1 94 0
 107 0000 0C94 0000 		jmp matrix_scan_kb
 108               	.LVL3:
 109               		.cfi_endproc
 110               	.LFE8:
 112               		.section	.text.matrix_rows,"ax",@progbits
 113               	.global	matrix_rows
 115               	matrix_rows:
 116               	.LFB13:
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 117               		.loc 1 116 0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 118:quantum/matrix.c **** }
 123               		.loc 1 118 0
 124 0000 85E0      		ldi r24,lo8(5)
 125               	/* epilogue start */
 126 0002 0895      		ret
 127               		.cfi_endproc
 128               	.LFE13:
 130               		.section	.text.matrix_cols,"ax",@progbits
 131               	.global	matrix_cols
 133               	matrix_cols:
 134               	.LFB14:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 135               		.loc 1 121 0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 123:quantum/matrix.c **** }
 141               		.loc 1 123 0
 142 0000 8DE0      		ldi r24,lo8(13)
 143               	/* epilogue start */
 144 0002 0895      		ret
 145               		.cfi_endproc
 146               	.LFE14:
 148               		.section	.text.matrix_init,"ax",@progbits
 149               	.global	matrix_init
 151               	matrix_init:
 152               	.LFB15:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #elif (DIODE_DIRECTION == ROW2COL)
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 153               		.loc 1 149 0
 154               		.cfi_startproc
 155 0000 CF93      		push r28
 156               	.LCFI0:
 157               		.cfi_def_cfa_offset 3
 158               		.cfi_offset 28, -2
 159 0002 DF93      		push r29
 160               	.LCFI1:
 161               		.cfi_def_cfa_offset 4
 162               		.cfi_offset 29, -3
 163               	/* prologue: function */
 164               	/* frame size = 0 */
 165               	/* stack size = 2 */
 166               	.L__stack_usage = 2
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 167               		.loc 1 153 0
 168 0004 85B7      		in r24,0x35
 169 0006 8068      		ori r24,lo8(-128)
 170 0008 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 171               		.loc 1 154 0
 172 000a 85B7      		in r24,0x35
 173 000c 8068      		ori r24,lo8(-128)
 174 000e 85BF      		out 0x35,r24
 175               	.LVL4:
 176 0010 A0E0      		ldi r26,lo8(row_pins)
 177 0012 B0E0      		ldi r27,hi8(row_pins)
 178 0014 40E0      		ldi r20,lo8(row_pins+5)
 179 0016 50E0      		ldi r21,hi8(row_pins+5)
 180               	.LBB27:
 181               	.LBB28:
 182               	.LBB29:
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 170:quantum/matrix.c ****     }
 171:quantum/matrix.c **** 
 172:quantum/matrix.c ****     matrix_init_quantum();
 173:quantum/matrix.c **** }
 174:quantum/matrix.c **** 
 175:quantum/matrix.c **** uint8_t matrix_scan(void)
 176:quantum/matrix.c **** {
 177:quantum/matrix.c **** 
 178:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 179:quantum/matrix.c **** 
 180:quantum/matrix.c ****     // Set row, read cols
 181:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 183:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 184:quantum/matrix.c **** 
 185:quantum/matrix.c ****             if (matrix_changed) {
 186:quantum/matrix.c ****                 debouncing = true;
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 188:quantum/matrix.c ****             }
 189:quantum/matrix.c **** 
 190:quantum/matrix.c **** #       else
 191:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 192:quantum/matrix.c **** #       endif
 193:quantum/matrix.c **** 
 194:quantum/matrix.c ****     }
 195:quantum/matrix.c **** 
 196:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 197:quantum/matrix.c **** 
 198:quantum/matrix.c ****     // Set col, read rows
 199:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 201:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 202:quantum/matrix.c ****             if (matrix_changed) {
 203:quantum/matrix.c ****                 debouncing = true;
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 205:quantum/matrix.c ****             }
 206:quantum/matrix.c **** #       else
 207:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 208:quantum/matrix.c **** #       endif
 209:quantum/matrix.c **** 
 210:quantum/matrix.c ****     }
 211:quantum/matrix.c **** 
 212:quantum/matrix.c **** #endif
 213:quantum/matrix.c **** 
 214:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 215:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 218:quantum/matrix.c ****             }
 219:quantum/matrix.c ****             debouncing = false;
 220:quantum/matrix.c ****         }
 221:quantum/matrix.c **** #   endif
 222:quantum/matrix.c **** 
 223:quantum/matrix.c ****     matrix_scan_quantum();
 224:quantum/matrix.c ****     return 1;
 225:quantum/matrix.c **** }
 226:quantum/matrix.c **** 
 227:quantum/matrix.c **** bool matrix_is_modified(void)
 228:quantum/matrix.c **** {
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 230:quantum/matrix.c ****     if (debouncing) return false;
 231:quantum/matrix.c **** #endif
 232:quantum/matrix.c ****     return true;
 233:quantum/matrix.c **** }
 234:quantum/matrix.c **** 
 235:quantum/matrix.c **** inline
 236:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 237:quantum/matrix.c **** {
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 239:quantum/matrix.c **** }
 240:quantum/matrix.c **** 
 241:quantum/matrix.c **** inline
 242:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 243:quantum/matrix.c **** {
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 245:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 246:quantum/matrix.c **** #ifdef MATRIX_MASKED
 247:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 248:quantum/matrix.c **** #else
 249:quantum/matrix.c ****     return matrix[row];
 250:quantum/matrix.c **** #endif
 251:quantum/matrix.c **** }
 252:quantum/matrix.c **** 
 253:quantum/matrix.c **** void matrix_print(void)
 254:quantum/matrix.c **** {
 255:quantum/matrix.c ****     print_matrix_header();
 256:quantum/matrix.c **** 
 257:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 258:quantum/matrix.c ****         phex(row); print(": ");
 259:quantum/matrix.c ****         print_matrix_row(row);
 260:quantum/matrix.c ****         print("\n");
 261:quantum/matrix.c ****     }
 262:quantum/matrix.c **** }
 263:quantum/matrix.c **** 
 264:quantum/matrix.c **** uint8_t matrix_key_count(void)
 265:quantum/matrix.c **** {
 266:quantum/matrix.c ****     uint8_t count = 0;
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 269:quantum/matrix.c ****     }
 270:quantum/matrix.c ****     return count;
 271:quantum/matrix.c **** }
 272:quantum/matrix.c **** 
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 276:quantum/matrix.c **** 
 277:quantum/matrix.c **** static void init_cols(void)
 278:quantum/matrix.c **** {
 279:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 283:quantum/matrix.c ****     }
 284:quantum/matrix.c **** }
 285:quantum/matrix.c **** 
 286:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 287:quantum/matrix.c **** {
 288:quantum/matrix.c ****     // Store last value of row prior to reading
 289:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 290:quantum/matrix.c **** 
 291:quantum/matrix.c ****     // Clear data in matrix row
 292:quantum/matrix.c ****     current_matrix[current_row] = 0;
 293:quantum/matrix.c **** 
 294:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 295:quantum/matrix.c ****     select_row(current_row);
 296:quantum/matrix.c ****     wait_us(30);
 297:quantum/matrix.c **** 
 298:quantum/matrix.c ****     // For each col...
 299:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 300:quantum/matrix.c **** 
 301:quantum/matrix.c ****         // Select the col pin to read (active low)
 302:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 304:quantum/matrix.c **** 
 305:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 306:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 307:quantum/matrix.c ****     }
 308:quantum/matrix.c **** 
 309:quantum/matrix.c ****     // Unselect row
 310:quantum/matrix.c ****     unselect_row(current_row);
 311:quantum/matrix.c **** 
 312:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 313:quantum/matrix.c **** }
 314:quantum/matrix.c **** 
 315:quantum/matrix.c **** static void select_row(uint8_t row)
 316:quantum/matrix.c **** {
 317:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 320:quantum/matrix.c **** }
 321:quantum/matrix.c **** 
 322:quantum/matrix.c **** static void unselect_row(uint8_t row)
 323:quantum/matrix.c **** {
 324:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 327:quantum/matrix.c **** }
 328:quantum/matrix.c **** 
 329:quantum/matrix.c **** static void unselect_rows(void)
 330:quantum/matrix.c **** {
 331:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 333:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 183               		.loc 1 333 0
 184 0018 C1E0      		ldi r28,lo8(1)
 185 001a D0E0      		ldi r29,0
 186               	.LVL5:
 187               	.L10:
 332:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 188               		.loc 1 332 0
 189 001c 8D91      		ld r24,X+
 190               	.LVL6:
 191               		.loc 1 333 0
 192 001e E82F      		mov r30,r24
 193 0020 E295      		swap r30
 194 0022 EF70      		andi r30,lo8(15)
 195 0024 F0E0      		ldi r31,0
 196 0026 61A1      		ldd r22,Z+33
 197 0028 8F70      		andi r24,lo8(15)
 198               	.LVL7:
 199 002a 9E01      		movw r18,r28
 200 002c 00C0      		rjmp 2f
 201               		1:
 202 002e 220F      		lsl r18
 203               		2:
 204 0030 8A95      		dec r24
 205 0032 02F4      		brpl 1b
 206 0034 922F      		mov r25,r18
 207 0036 9095      		com r25
 208 0038 9623      		and r25,r22
 209 003a 91A3      		std Z+33,r25
 210               	.LVL8:
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 211               		.loc 1 334 0
 212 003c 82A1      		ldd r24,Z+34
 213 003e 822B      		or r24,r18
 214 0040 82A3      		std Z+34,r24
 215               	.LVL9:
 216               	.LBE29:
 331:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 217               		.loc 1 331 0
 218 0042 4A17      		cp r20,r26
 219 0044 5B07      		cpc r21,r27
 220 0046 01F4      		brne .L10
 221 0048 A0E0      		ldi r26,lo8(col_pins)
 222 004a B0E0      		ldi r27,hi8(col_pins)
 223               	.LVL10:
 224               	.LBE28:
 225               	.LBE27:
 226               	.LBB30:
 227               	.LBB31:
 228               	.LBB32:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 229               		.loc 1 281 0
 230 004c 61E0      		ldi r22,lo8(1)
 231 004e 70E0      		ldi r23,0
 232               	.L11:
 233               	.LVL11:
 280:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 234               		.loc 1 280 0
 235 0050 8D91      		ld r24,X+
 236               	.LVL12:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 237               		.loc 1 281 0
 238 0052 E82F      		mov r30,r24
 239 0054 E295      		swap r30
 240 0056 EF70      		andi r30,lo8(15)
 241 0058 F0E0      		ldi r31,0
 242 005a 41A1      		ldd r20,Z+33
 243 005c 8F70      		andi r24,lo8(15)
 244               	.LVL13:
 245 005e 9B01      		movw r18,r22
 246 0060 00C0      		rjmp 2f
 247               		1:
 248 0062 220F      		lsl r18
 249               		2:
 250 0064 8A95      		dec r24
 251 0066 02F4      		brpl 1b
 252 0068 922F      		mov r25,r18
 253 006a 9095      		com r25
 254 006c 9423      		and r25,r20
 255 006e 91A3      		std Z+33,r25
 256               	.LVL14:
 282:quantum/matrix.c ****     }
 257               		.loc 1 282 0
 258 0070 82A1      		ldd r24,Z+34
 259 0072 822B      		or r24,r18
 260 0074 82A3      		std Z+34,r24
 261               	.LVL15:
 262               	.LBE32:
 279:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 263               		.loc 1 279 0
 264 0076 80E0      		ldi r24,hi8(col_pins+13)
 265 0078 A030      		cpi r26,lo8(col_pins+13)
 266 007a B807      		cpc r27,r24
 267 007c 01F4      		brne .L11
 268               	.LVL16:
 269               	.LBE31:
 270               	.LBE30:
 271               	.LBB33:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 272               		.loc 1 168 0
 273 007e 1092 0000 		sts matrix+1,__zero_reg__
 274 0082 1092 0000 		sts matrix,__zero_reg__
 169:quantum/matrix.c ****     }
 275               		.loc 1 169 0
 276 0086 1092 0000 		sts matrix_debouncing+1,__zero_reg__
 277 008a 1092 0000 		sts matrix_debouncing,__zero_reg__
 278               	.LVL17:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 279               		.loc 1 168 0
 280 008e 1092 0000 		sts matrix+2+1,__zero_reg__
 281 0092 1092 0000 		sts matrix+2,__zero_reg__
 169:quantum/matrix.c ****     }
 282               		.loc 1 169 0
 283 0096 1092 0000 		sts matrix_debouncing+2+1,__zero_reg__
 284 009a 1092 0000 		sts matrix_debouncing+2,__zero_reg__
 285               	.LVL18:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 286               		.loc 1 168 0
 287 009e 1092 0000 		sts matrix+4+1,__zero_reg__
 288 00a2 1092 0000 		sts matrix+4,__zero_reg__
 169:quantum/matrix.c ****     }
 289               		.loc 1 169 0
 290 00a6 1092 0000 		sts matrix_debouncing+4+1,__zero_reg__
 291 00aa 1092 0000 		sts matrix_debouncing+4,__zero_reg__
 292               	.LVL19:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 293               		.loc 1 168 0
 294 00ae 1092 0000 		sts matrix+6+1,__zero_reg__
 295 00b2 1092 0000 		sts matrix+6,__zero_reg__
 169:quantum/matrix.c ****     }
 296               		.loc 1 169 0
 297 00b6 1092 0000 		sts matrix_debouncing+6+1,__zero_reg__
 298 00ba 1092 0000 		sts matrix_debouncing+6,__zero_reg__
 299               	.LVL20:
 168:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 300               		.loc 1 168 0
 301 00be 1092 0000 		sts matrix+8+1,__zero_reg__
 302 00c2 1092 0000 		sts matrix+8,__zero_reg__
 169:quantum/matrix.c ****     }
 303               		.loc 1 169 0
 304 00c6 1092 0000 		sts matrix_debouncing+8+1,__zero_reg__
 305 00ca 1092 0000 		sts matrix_debouncing+8,__zero_reg__
 306               	.LVL21:
 307               	/* epilogue start */
 308               	.LBE33:
 173:quantum/matrix.c **** 
 309               		.loc 1 173 0
 310 00ce DF91      		pop r29
 311 00d0 CF91      		pop r28
 172:quantum/matrix.c **** }
 312               		.loc 1 172 0
 313 00d2 0C94 0000 		jmp matrix_init_quantum
 314               	.LVL22:
 315               		.cfi_endproc
 316               	.LFE15:
 318               		.section	.text.matrix_scan,"ax",@progbits
 319               	.global	matrix_scan
 321               	matrix_scan:
 322               	.LFB16:
 176:quantum/matrix.c **** 
 323               		.loc 1 176 0
 324               		.cfi_startproc
 325 0000 6F92      		push r6
 326               	.LCFI2:
 327               		.cfi_def_cfa_offset 3
 328               		.cfi_offset 6, -2
 329 0002 7F92      		push r7
 330               	.LCFI3:
 331               		.cfi_def_cfa_offset 4
 332               		.cfi_offset 7, -3
 333 0004 9F92      		push r9
 334               	.LCFI4:
 335               		.cfi_def_cfa_offset 5
 336               		.cfi_offset 9, -4
 337 0006 AF92      		push r10
 338               	.LCFI5:
 339               		.cfi_def_cfa_offset 6
 340               		.cfi_offset 10, -5
 341 0008 BF92      		push r11
 342               	.LCFI6:
 343               		.cfi_def_cfa_offset 7
 344               		.cfi_offset 11, -6
 345 000a CF92      		push r12
 346               	.LCFI7:
 347               		.cfi_def_cfa_offset 8
 348               		.cfi_offset 12, -7
 349 000c DF92      		push r13
 350               	.LCFI8:
 351               		.cfi_def_cfa_offset 9
 352               		.cfi_offset 13, -8
 353 000e EF92      		push r14
 354               	.LCFI9:
 355               		.cfi_def_cfa_offset 10
 356               		.cfi_offset 14, -9
 357 0010 FF92      		push r15
 358               	.LCFI10:
 359               		.cfi_def_cfa_offset 11
 360               		.cfi_offset 15, -10
 361 0012 0F93      		push r16
 362               	.LCFI11:
 363               		.cfi_def_cfa_offset 12
 364               		.cfi_offset 16, -11
 365 0014 1F93      		push r17
 366               	.LCFI12:
 367               		.cfi_def_cfa_offset 13
 368               		.cfi_offset 17, -12
 369 0016 CF93      		push r28
 370               	.LCFI13:
 371               		.cfi_def_cfa_offset 14
 372               		.cfi_offset 28, -13
 373 0018 DF93      		push r29
 374               	.LCFI14:
 375               		.cfi_def_cfa_offset 15
 376               		.cfi_offset 29, -14
 377               	/* prologue: function */
 378               	/* frame size = 0 */
 379               	/* stack size = 13 */
 380               	.L__stack_usage = 13
 381               	.LVL23:
 382 001a C0E0      		ldi r28,lo8(matrix_debouncing)
 383 001c D0E0      		ldi r29,hi8(matrix_debouncing)
 384 001e 00E0      		ldi r16,lo8(row_pins)
 385 0020 10E0      		ldi r17,hi8(row_pins)
 386               	.LBB47:
 387               	.LBB48:
 388               	.LBB49:
 389               	.LBB50:
 390               	.LBB51:
 391               	.LBB52:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 392               		.loc 1 318 0
 393 0022 EE24      		clr r14
 394 0024 E394      		inc r14
 395 0026 F12C      		mov r15,__zero_reg__
 396               	.LBE52:
 397               	.LBE51:
 398               	.LBE50:
 399               	.LBE49:
 186:quantum/matrix.c ****                 debouncing_time = timer_read();
 400               		.loc 1 186 0
 401 0028 BB24      		clr r11
 402 002a B394      		inc r11
 403               	.LVL24:
 404               	.L18:
 405               	.LBB65:
 406               	.LBB63:
 289:quantum/matrix.c **** 
 407               		.loc 1 289 0
 408 002c C880      		ld r12,Y
 409 002e D980      		ldd r13,Y+1
 410               	.LVL25:
 292:quantum/matrix.c **** 
 411               		.loc 1 292 0
 412 0030 1982      		std Y+1,__zero_reg__
 413 0032 1882      		st Y,__zero_reg__
 414               	.LVL26:
 415               	.LBB54:
 416               	.LBB53:
 317:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 417               		.loc 1 317 0
 418 0034 D801      		movw r26,r16
 419 0036 8D91      		ld r24,X+
 420 0038 8D01      		movw r16,r26
 421               	.LVL27:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 422               		.loc 1 318 0
 423 003a E82F      		mov r30,r24
 424 003c E295      		swap r30
 425 003e EF70      		andi r30,lo8(15)
 426 0040 F0E0      		ldi r31,0
 427 0042 91A1      		ldd r25,Z+33
 428 0044 8F70      		andi r24,lo8(15)
 429               	.LVL28:
 430 0046 9701      		movw r18,r14
 431 0048 00C0      		rjmp 2f
 432               		1:
 433 004a 220F      		lsl r18
 434               		2:
 435 004c 8A95      		dec r24
 436 004e 02F4      		brpl 1b
 437 0050 892F      		mov r24,r25
 438 0052 822B      		or r24,r18
 439 0054 81A3      		std Z+33,r24
 440               	.LVL29:
 319:quantum/matrix.c **** }
 441               		.loc 1 319 0
 442 0056 82A1      		ldd r24,Z+34
 443 0058 A22E      		mov r10,r18
 444 005a A094      		com r10
 445 005c 8A21      		and r24,r10
 446 005e 82A3      		std Z+34,r24
 447               	.LVL30:
 448               	.LBE53:
 449               	.LBE54:
 450               	.LBB55:
 451               	.LBB56:
 452               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 453               		.loc 2 276 0
 454 0060 B0EA      		ldi r27,lo8(-96)
 455 0062 BA95      	1:	dec r27
 456 0064 01F4      		brne 1b
 457               	.LVL31:
 458 0066 80E0      		ldi r24,lo8(col_pins)
 459 0068 682E      		mov r6,r24
 460 006a 80E0      		ldi r24,hi8(col_pins)
 461 006c 782E      		mov r7,r24
 462 006e 90E0      		ldi r25,0
 463 0070 80E0      		ldi r24,0
 464               	.LVL32:
 465               	.L16:
 466               	.LBE56:
 467               	.LBE55:
 468               	.LBB57:
 469               	.LBB58:
 302:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 470               		.loc 1 302 0
 471 0072 D301      		movw r26,r6
 472 0074 7D91      		ld r23,X+
 473 0076 3D01      		movw r6,r26
 474               	.LVL33:
 303:quantum/matrix.c **** 
 475               		.loc 1 303 0
 476 0078 472F      		mov r20,r23
 477 007a 4295      		swap r20
 478 007c 4F70      		andi r20,lo8(15)
 479 007e 50E0      		ldi r21,0
 480 0080 DA01      		movw r26,r20
 481 0082 9096      		adiw r26,32
 482 0084 9C90      		ld r9,X
 483               	.LVL34:
 306:quantum/matrix.c ****     }
 484               		.loc 1 306 0
 485 0086 4881      		ld r20,Y
 486 0088 5981      		ldd r21,Y+1
 303:quantum/matrix.c **** 
 487               		.loc 1 303 0
 488 008a 7F70      		andi r23,lo8(15)
 489               	.LVL35:
 490 008c D701      		movw r26,r14
 491 008e 00C0      		rjmp 2f
 492               		1:
 493 0090 AA0F      		lsl r26
 494 0092 BB1F      		rol r27
 495               		2:
 496 0094 7A95      		dec r23
 497 0096 02F4      		brpl 1b
 498 0098 BD01      		movw r22,r26
 499 009a 6921      		and r22,r9
 306:quantum/matrix.c ****     }
 500               		.loc 1 306 0
 501 009c 01F0      		breq .+2
 502 009e 00C0      		rjmp .L22
 503 00a0 B701      		movw r22,r14
 504 00a2 082E      		mov r0,r24
 505 00a4 00C0      		rjmp 2f
 506               		1:
 507 00a6 660F      		lsl r22
 508 00a8 771F      		rol r23
 509               		2:
 510 00aa 0A94      		dec r0
 511 00ac 02F4      		brpl 1b
 512               	.LVL36:
 513               	.L15:
 514 00ae 462B      		or r20,r22
 515 00b0 572B      		or r21,r23
 516 00b2 5983      		std Y+1,r21
 517 00b4 4883      		st Y,r20
 518               	.LVL37:
 519 00b6 0196      		adiw r24,1
 520               	.LVL38:
 521               	.LBE58:
 299:quantum/matrix.c **** 
 522               		.loc 1 299 0
 523 00b8 8D30      		cpi r24,13
 524 00ba 9105      		cpc r25,__zero_reg__
 525 00bc 01F4      		brne .L16
 526               	.LVL39:
 527               	.LBE57:
 528               	.LBB60:
 529               	.LBB61:
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 530               		.loc 1 325 0
 531 00be 81A1      		ldd r24,Z+33
 532               	.LVL40:
 533 00c0 8A21      		and r24,r10
 534 00c2 81A3      		std Z+33,r24
 535               	.LVL41:
 326:quantum/matrix.c **** }
 536               		.loc 1 326 0
 537 00c4 82A1      		ldd r24,Z+34
 538 00c6 282B      		or r18,r24
 539 00c8 22A3      		std Z+34,r18
 540               	.LVL42:
 541               	.LBE61:
 542               	.LBE60:
 543               	.LBE63:
 544               	.LBE65:
 185:quantum/matrix.c ****                 debouncing = true;
 545               		.loc 1 185 0
 546 00ca 8881      		ld r24,Y
 547 00cc 9981      		ldd r25,Y+1
 548 00ce C816      		cp r12,r24
 549 00d0 D906      		cpc r13,r25
 550 00d2 01F0      		breq .L17
 186:quantum/matrix.c ****                 debouncing_time = timer_read();
 551               		.loc 1 186 0
 552 00d4 B092 0000 		sts debouncing,r11
 187:quantum/matrix.c ****             }
 553               		.loc 1 187 0
 554 00d8 0E94 0000 		call timer_read
 555               	.LVL43:
 556 00dc 9093 0000 		sts debouncing_time+1,r25
 557 00e0 8093 0000 		sts debouncing_time,r24
 558               	.L17:
 559               	.LVL44:
 560 00e4 2296      		adiw r28,2
 561               	.LBE48:
 181:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 562               		.loc 1 181 0 discriminator 2
 563 00e6 B0E0      		ldi r27,hi8(row_pins+5)
 564 00e8 0030      		cpi r16,lo8(row_pins+5)
 565 00ea 1B07      		cpc r17,r27
 566 00ec 01F0      		breq .+2
 567 00ee 00C0      		rjmp .L18
 568               	.LBE47:
 215:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 569               		.loc 1 215 0
 570 00f0 8091 0000 		lds r24,debouncing
 571 00f4 8823      		tst r24
 572 00f6 01F0      		breq .L20
 215:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 573               		.loc 1 215 0 is_stmt 0 discriminator 1
 574 00f8 8091 0000 		lds r24,debouncing_time
 575 00fc 9091 0000 		lds r25,debouncing_time+1
 576 0100 0E94 0000 		call timer_elapsed
 577               	.LVL45:
 578 0104 0697      		sbiw r24,6
 579 0106 00F0      		brlo .L20
 580               	.LVL46:
 581               	.LBB68:
 217:quantum/matrix.c ****             }
 582               		.loc 1 217 0 is_stmt 1
 583 0108 8091 0000 		lds r24,matrix_debouncing
 584 010c 9091 0000 		lds r25,matrix_debouncing+1
 585 0110 9093 0000 		sts matrix+1,r25
 586 0114 8093 0000 		sts matrix,r24
 587               	.LVL47:
 588 0118 8091 0000 		lds r24,matrix_debouncing+2
 589 011c 9091 0000 		lds r25,matrix_debouncing+2+1
 590 0120 9093 0000 		sts matrix+2+1,r25
 591 0124 8093 0000 		sts matrix+2,r24
 592               	.LVL48:
 593 0128 8091 0000 		lds r24,matrix_debouncing+4
 594 012c 9091 0000 		lds r25,matrix_debouncing+4+1
 595 0130 9093 0000 		sts matrix+4+1,r25
 596 0134 8093 0000 		sts matrix+4,r24
 597               	.LVL49:
 598 0138 8091 0000 		lds r24,matrix_debouncing+6
 599 013c 9091 0000 		lds r25,matrix_debouncing+6+1
 600 0140 9093 0000 		sts matrix+6+1,r25
 601 0144 8093 0000 		sts matrix+6,r24
 602               	.LVL50:
 603 0148 8091 0000 		lds r24,matrix_debouncing+8
 604 014c 9091 0000 		lds r25,matrix_debouncing+8+1
 605 0150 9093 0000 		sts matrix+8+1,r25
 606 0154 8093 0000 		sts matrix+8,r24
 607               	.LVL51:
 608               	.LBE68:
 219:quantum/matrix.c ****         }
 609               		.loc 1 219 0
 610 0158 1092 0000 		sts debouncing,__zero_reg__
 611               	.LVL52:
 612               	.L20:
 223:quantum/matrix.c ****     return 1;
 613               		.loc 1 223 0
 614 015c 0E94 0000 		call matrix_scan_quantum
 615               	.LVL53:
 225:quantum/matrix.c **** 
 616               		.loc 1 225 0
 617 0160 81E0      		ldi r24,lo8(1)
 618               	/* epilogue start */
 619 0162 DF91      		pop r29
 620 0164 CF91      		pop r28
 621 0166 1F91      		pop r17
 622 0168 0F91      		pop r16
 623               	.LVL54:
 624 016a FF90      		pop r15
 625 016c EF90      		pop r14
 626 016e DF90      		pop r13
 627 0170 CF90      		pop r12
 628 0172 BF90      		pop r11
 629 0174 AF90      		pop r10
 630 0176 9F90      		pop r9
 631 0178 7F90      		pop r7
 632 017a 6F90      		pop r6
 633 017c 0895      		ret
 634               	.LVL55:
 635               	.L22:
 636               	.LBB69:
 637               	.LBB67:
 638               	.LBB66:
 639               	.LBB64:
 640               	.LBB62:
 641               	.LBB59:
 306:quantum/matrix.c ****     }
 642               		.loc 1 306 0
 643 017e 70E0      		ldi r23,0
 644               	.LVL56:
 645 0180 60E0      		ldi r22,0
 646 0182 00C0      		rjmp .L15
 647               	.LBE59:
 648               	.LBE62:
 649               	.LBE64:
 650               	.LBE66:
 651               	.LBE67:
 652               	.LBE69:
 653               		.cfi_endproc
 654               	.LFE16:
 656               		.section	.text.matrix_is_modified,"ax",@progbits
 657               	.global	matrix_is_modified
 659               	matrix_is_modified:
 660               	.LFB17:
 228:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 661               		.loc 1 228 0
 662               		.cfi_startproc
 663               	/* prologue: function */
 664               	/* frame size = 0 */
 665               	/* stack size = 0 */
 666               	.L__stack_usage = 0
 230:quantum/matrix.c **** #endif
 667               		.loc 1 230 0
 668 0000 9091 0000 		lds r25,debouncing
 233:quantum/matrix.c **** 
 669               		.loc 1 233 0
 670 0004 81E0      		ldi r24,lo8(1)
 671 0006 8927      		eor r24,r25
 672               	/* epilogue start */
 673 0008 0895      		ret
 674               		.cfi_endproc
 675               	.LFE17:
 677               		.section	.text.matrix_is_on,"ax",@progbits
 678               	.global	matrix_is_on
 680               	matrix_is_on:
 681               	.LFB18:
 237:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 682               		.loc 1 237 0
 683               		.cfi_startproc
 684               	.LVL57:
 685               	/* prologue: function */
 686               	/* frame size = 0 */
 687               	/* stack size = 0 */
 688               	.L__stack_usage = 0
 238:quantum/matrix.c **** }
 689               		.loc 1 238 0
 690 0000 E82F      		mov r30,r24
 691 0002 F0E0      		ldi r31,0
 692 0004 EE0F      		lsl r30
 693 0006 FF1F      		rol r31
 694               	.LVL58:
 695 0008 E050      		subi r30,lo8(-(matrix))
 696 000a F040      		sbci r31,hi8(-(matrix))
 697 000c 81E0      		ldi r24,lo8(1)
 698 000e 90E0      		ldi r25,0
 699 0010 6230      		cpi r22,lo8(2)
 700 0012 00F4      		brsh .L27
 701 0014 80E0      		ldi r24,0
 702               	.L27:
 703 0016 2081      		ld r18,Z
 704 0018 3181      		ldd r19,Z+1
 705 001a 8223      		and r24,r18
 239:quantum/matrix.c **** 
 706               		.loc 1 239 0
 707 001c 8170      		andi r24,lo8(1)
 708               	/* epilogue start */
 709 001e 0895      		ret
 710               		.cfi_endproc
 711               	.LFE18:
 713               		.section	.text.matrix_get_row,"ax",@progbits
 714               	.global	matrix_get_row
 716               	matrix_get_row:
 717               	.LFB19:
 243:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 718               		.loc 1 243 0
 719               		.cfi_startproc
 720               	.LVL59:
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 0 */
 724               	.L__stack_usage = 0
 249:quantum/matrix.c **** #endif
 725               		.loc 1 249 0
 726 0000 E82F      		mov r30,r24
 727 0002 F0E0      		ldi r31,0
 728 0004 EE0F      		lsl r30
 729 0006 FF1F      		rol r31
 730               	.LVL60:
 731 0008 E050      		subi r30,lo8(-(matrix))
 732 000a F040      		sbci r31,hi8(-(matrix))
 251:quantum/matrix.c **** 
 733               		.loc 1 251 0
 734 000c 8081      		ld r24,Z
 735 000e 9181      		ldd r25,Z+1
 736               	/* epilogue start */
 737 0010 0895      		ret
 738               		.cfi_endproc
 739               	.LFE19:
 741               		.section	.text.matrix_print,"ax",@progbits
 742               	.global	matrix_print
 744               	matrix_print:
 745               	.LFB20:
 254:quantum/matrix.c ****     print_matrix_header();
 746               		.loc 1 254 0
 747               		.cfi_startproc
 748 0000 CF92      		push r12
 749               	.LCFI15:
 750               		.cfi_def_cfa_offset 3
 751               		.cfi_offset 12, -2
 752 0002 DF92      		push r13
 753               	.LCFI16:
 754               		.cfi_def_cfa_offset 4
 755               		.cfi_offset 13, -3
 756 0004 EF92      		push r14
 757               	.LCFI17:
 758               		.cfi_def_cfa_offset 5
 759               		.cfi_offset 14, -4
 760 0006 FF92      		push r15
 761               	.LCFI18:
 762               		.cfi_def_cfa_offset 6
 763               		.cfi_offset 15, -5
 764 0008 0F93      		push r16
 765               	.LCFI19:
 766               		.cfi_def_cfa_offset 7
 767               		.cfi_offset 16, -6
 768 000a 1F93      		push r17
 769               	.LCFI20:
 770               		.cfi_def_cfa_offset 8
 771               		.cfi_offset 17, -7
 772 000c CF93      		push r28
 773               	.LCFI21:
 774               		.cfi_def_cfa_offset 9
 775               		.cfi_offset 28, -8
 776 000e DF93      		push r29
 777               	.LCFI22:
 778               		.cfi_def_cfa_offset 10
 779               		.cfi_offset 29, -9
 780               	/* prologue: function */
 781               	/* frame size = 0 */
 782               	/* stack size = 8 */
 783               	.L__stack_usage = 8
 255:quantum/matrix.c **** 
 784               		.loc 1 255 0
 785 0010 80E0      		ldi r24,lo8(__c.1953)
 786 0012 90E0      		ldi r25,hi8(__c.1953)
 787 0014 0E94 0000 		call xputs
 788 0018 80E0      		ldi r24,lo8(matrix)
 789 001a E82E      		mov r14,r24
 790 001c 80E0      		ldi r24,hi8(matrix)
 791 001e F82E      		mov r15,r24
 792 0020 D0E0      		ldi r29,0
 793 0022 C0E0      		ldi r28,0
 794               	.LBB70:
 258:quantum/matrix.c ****         print_matrix_row(row);
 795               		.loc 1 258 0
 796 0024 90E0      		ldi r25,lo8(__c.1956)
 797 0026 C92E      		mov r12,r25
 798 0028 90E0      		ldi r25,hi8(__c.1956)
 799 002a D92E      		mov r13,r25
 259:quantum/matrix.c ****         print("\n");
 800               		.loc 1 259 0
 801 002c 00E0      		ldi r16,lo8(__c.1960)
 802 002e 10E0      		ldi r17,hi8(__c.1960)
 803               	.L30:
 258:quantum/matrix.c ****         print_matrix_row(row);
 804               		.loc 1 258 0 discriminator 3
 805 0030 DF93      		push r29
 806               	.LCFI23:
 807               		.cfi_def_cfa_offset 11
 808 0032 CF93      		push r28
 809               	.LCFI24:
 810               		.cfi_def_cfa_offset 12
 811 0034 DF92      		push r13
 812               	.LCFI25:
 813               		.cfi_def_cfa_offset 13
 814 0036 CF92      		push r12
 815               	.LCFI26:
 816               		.cfi_def_cfa_offset 14
 817 0038 0E94 0000 		call __xprintf
 818 003c 80E0      		ldi r24,lo8(__c.1958)
 819 003e 90E0      		ldi r25,hi8(__c.1958)
 820 0040 0E94 0000 		call xputs
 259:quantum/matrix.c ****         print("\n");
 821               		.loc 1 259 0 discriminator 3
 822 0044 F701      		movw r30,r14
 823 0046 8191      		ld r24,Z+
 824 0048 9191      		ld r25,Z+
 825 004a 7F01      		movw r14,r30
 826 004c 0E94 0000 		call bitrev16
 827 0050 9F93      		push r25
 828               	.LCFI27:
 829               		.cfi_def_cfa_offset 15
 830 0052 8F93      		push r24
 831               	.LCFI28:
 832               		.cfi_def_cfa_offset 16
 833 0054 1F93      		push r17
 834               	.LCFI29:
 835               		.cfi_def_cfa_offset 17
 836 0056 0F93      		push r16
 837               	.LCFI30:
 838               		.cfi_def_cfa_offset 18
 839 0058 0E94 0000 		call __xprintf
 260:quantum/matrix.c ****     }
 840               		.loc 1 260 0 discriminator 3
 841 005c 80E0      		ldi r24,lo8(__c.1962)
 842 005e 90E0      		ldi r25,hi8(__c.1962)
 843 0060 0E94 0000 		call xputs
 844 0064 2196      		adiw r28,1
 257:quantum/matrix.c ****         phex(row); print(": ");
 845               		.loc 1 257 0 discriminator 3
 846 0066 8DB7      		in r24,__SP_L__
 847 0068 9EB7      		in r25,__SP_H__
 848 006a 0896      		adiw r24,8
 849 006c 0FB6      		in __tmp_reg__,__SREG__
 850 006e F894      		cli
 851 0070 9EBF      		out __SP_H__,r25
 852 0072 0FBE      		out __SREG__,__tmp_reg__
 853 0074 8DBF      		out __SP_L__,r24
 854               	.LCFI31:
 855               		.cfi_def_cfa_offset 10
 856 0076 C530      		cpi r28,5
 857 0078 D105      		cpc r29,__zero_reg__
 858 007a 01F4      		brne .L30
 859               	/* epilogue start */
 860               	.LBE70:
 262:quantum/matrix.c **** 
 861               		.loc 1 262 0
 862 007c DF91      		pop r29
 863 007e CF91      		pop r28
 864 0080 1F91      		pop r17
 865 0082 0F91      		pop r16
 866 0084 FF90      		pop r15
 867 0086 EF90      		pop r14
 868 0088 DF90      		pop r13
 869 008a CF90      		pop r12
 870 008c 0895      		ret
 871               		.cfi_endproc
 872               	.LFE20:
 874               		.section	.text.matrix_key_count,"ax",@progbits
 875               	.global	matrix_key_count
 877               	matrix_key_count:
 878               	.LFB21:
 265:quantum/matrix.c ****     uint8_t count = 0;
 879               		.loc 1 265 0
 880               		.cfi_startproc
 881 0000 0F93      		push r16
 882               	.LCFI32:
 883               		.cfi_def_cfa_offset 3
 884               		.cfi_offset 16, -2
 885 0002 1F93      		push r17
 886               	.LCFI33:
 887               		.cfi_def_cfa_offset 4
 888               		.cfi_offset 17, -3
 889 0004 CF93      		push r28
 890               	.LCFI34:
 891               		.cfi_def_cfa_offset 5
 892               		.cfi_offset 28, -4
 893               	/* prologue: function */
 894               	/* frame size = 0 */
 895               	/* stack size = 3 */
 896               	.L__stack_usage = 3
 897               	.LVL61:
 898 0006 00E0      		ldi r16,lo8(matrix)
 899 0008 10E0      		ldi r17,hi8(matrix)
 266:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 900               		.loc 1 266 0
 901 000a C0E0      		ldi r28,0
 902               	.LVL62:
 903               	.L33:
 904               	.LBB71:
 268:quantum/matrix.c ****     }
 905               		.loc 1 268 0 discriminator 3
 906 000c F801      		movw r30,r16
 907 000e 8191      		ld r24,Z+
 908 0010 9191      		ld r25,Z+
 909 0012 8F01      		movw r16,r30
 910 0014 0E94 0000 		call bitpop16
 911               	.LVL63:
 912 0018 C80F      		add r28,r24
 913               	.LVL64:
 267:quantum/matrix.c ****         count += matrix_bitpop(i);
 914               		.loc 1 267 0 discriminator 3
 915 001a F0E0      		ldi r31,hi8(matrix+10)
 916 001c 0030      		cpi r16,lo8(matrix+10)
 917 001e 1F07      		cpc r17,r31
 918 0020 01F4      		brne .L33
 919               	.LBE71:
 271:quantum/matrix.c **** 
 920               		.loc 1 271 0
 921 0022 8C2F      		mov r24,r28
 922               	/* epilogue start */
 923 0024 CF91      		pop r28
 924               	.LVL65:
 925 0026 1F91      		pop r17
 926 0028 0F91      		pop r16
 927 002a 0895      		ret
 928               		.cfi_endproc
 929               	.LFE21:
 931               		.section	.progmem.data.__c.1962,"a",@progbits
 934               	__c.1962:
 935 0000 0A00      		.string	"\n"
 936               		.section	.progmem.data.__c.1960,"a",@progbits
 939               	__c.1960:
 940 0000 2530 3136 		.string	"%016b"
 940      6200 
 941               		.section	.progmem.data.__c.1958,"a",@progbits
 944               	__c.1958:
 945 0000 3A20 00   		.string	": "
 946               		.section	.progmem.data.__c.1956,"a",@progbits
 949               	__c.1956:
 950 0000 2530 3258 		.string	"%02X"
 950      00
 951               		.section	.progmem.data.__c.1953,"a",@progbits
 954               	__c.1953:
 955 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 955      2030 3132 
 955      3334 3536 
 955      3738 3941 
 955      4243 4445 
 956               		.section	.bss.matrix_debouncing,"aw",@nobits
 959               	matrix_debouncing:
 960 0000 0000 0000 		.zero	10
 960      0000 0000 
 960      0000 
 961               		.section	.bss.matrix,"aw",@nobits
 964               	matrix:
 965 0000 0000 0000 		.zero	10
 965      0000 0000 
 965      0000 
 966               		.section	.rodata.col_pins,"a",@progbits
 969               	col_pins:
 970 0000 96        		.byte	-106
 971 0001 97        		.byte	-105
 972 0002 34        		.byte	52
 973 0003 35        		.byte	53
 974 0004 36        		.byte	54
 975 0005 F7        		.byte	-9
 976 0006 F6        		.byte	-10
 977 0007 F5        		.byte	-11
 978 0008 F4        		.byte	-12
 979 0009 F1        		.byte	-15
 980 000a F0        		.byte	-16
 981 000b 31        		.byte	49
 982 000c 30        		.byte	48
 983               		.section	.rodata.row_pins,"a",@progbits
 986               	row_pins:
 987 0000 32        		.byte	50
 988 0001 33        		.byte	51
 989 0002 37        		.byte	55
 990 0003 90        		.byte	-112
 991 0004 91        		.byte	-111
 992               		.section	.bss.debouncing,"aw",@nobits
 995               	debouncing:
 996 0000 00        		.zero	1
 997               		.section	.bss.debouncing_time,"aw",@nobits
 1000               	debouncing_time:
 1001 0000 0000      		.zero	2
 1002               		.text
 1003               	.Letext0:
 1004               		.file 3 "/usr/avr/include/stdint.h"
 1005               		.file 4 "./tmk_core/common/debug.h"
 1006               		.file 5 "./tmk_core/common/avr/xprintf.h"
 1007               		.file 6 "./tmk_core/common/matrix.h"
 1008               		.file 7 "./tmk_core/common/timer.h"
 1009               		.file 8 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
 /var/tmp/ccQOF33a.s:2      *ABS*:000000000000003e __SP_H__
 /var/tmp/ccQOF33a.s:3      *ABS*:000000000000003d __SP_L__
 /var/tmp/ccQOF33a.s:4      *ABS*:000000000000003f __SREG__
 /var/tmp/ccQOF33a.s:5      *ABS*:0000000000000000 __tmp_reg__
 /var/tmp/ccQOF33a.s:6      *ABS*:0000000000000001 __zero_reg__
 /var/tmp/ccQOF33a.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
 /var/tmp/ccQOF33a.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
 /var/tmp/ccQOF33a.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
 /var/tmp/ccQOF33a.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
 /var/tmp/ccQOF33a.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
 /var/tmp/ccQOF33a.s:81     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
 /var/tmp/ccQOF33a.s:98     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
 /var/tmp/ccQOF33a.s:115    .text.matrix_rows:0000000000000000 matrix_rows
 /var/tmp/ccQOF33a.s:133    .text.matrix_cols:0000000000000000 matrix_cols
 /var/tmp/ccQOF33a.s:151    .text.matrix_init:0000000000000000 matrix_init
 /var/tmp/ccQOF33a.s:986    .rodata.row_pins:0000000000000000 row_pins
 /var/tmp/ccQOF33a.s:969    .rodata.col_pins:0000000000000000 col_pins
 /var/tmp/ccQOF33a.s:964    .bss.matrix:0000000000000000 matrix
 /var/tmp/ccQOF33a.s:959    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
 /var/tmp/ccQOF33a.s:321    .text.matrix_scan:0000000000000000 matrix_scan
 /var/tmp/ccQOF33a.s:995    .bss.debouncing:0000000000000000 debouncing
 /var/tmp/ccQOF33a.s:1000   .bss.debouncing_time:0000000000000000 debouncing_time
 /var/tmp/ccQOF33a.s:659    .text.matrix_is_modified:0000000000000000 matrix_is_modified
 /var/tmp/ccQOF33a.s:680    .text.matrix_is_on:0000000000000000 matrix_is_on
 /var/tmp/ccQOF33a.s:716    .text.matrix_get_row:0000000000000000 matrix_get_row
 /var/tmp/ccQOF33a.s:744    .text.matrix_print:0000000000000000 matrix_print
 /var/tmp/ccQOF33a.s:954    .progmem.data.__c.1953:0000000000000000 __c.1953
 /var/tmp/ccQOF33a.s:949    .progmem.data.__c.1956:0000000000000000 __c.1956
 /var/tmp/ccQOF33a.s:939    .progmem.data.__c.1960:0000000000000000 __c.1960
 /var/tmp/ccQOF33a.s:944    .progmem.data.__c.1958:0000000000000000 __c.1958
 /var/tmp/ccQOF33a.s:934    .progmem.data.__c.1962:0000000000000000 __c.1962
 /var/tmp/ccQOF33a.s:877    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
