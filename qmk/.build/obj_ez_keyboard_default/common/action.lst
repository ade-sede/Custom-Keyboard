   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:./tmk_core/common/action.c ****  *
  49:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:./tmk_core/common/action.c ****  */
  51:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:./tmk_core/common/action.c **** {
  16               		.loc 1 52 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  54:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  56:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:./tmk_core/common/action.c ****         retro_tapping_counter++;
  58:./tmk_core/common/action.c **** #endif
  59:./tmk_core/common/action.c ****     }
  60:./tmk_core/common/action.c **** 
  61:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:./tmk_core/common/action.c ****     }
  65:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:./tmk_core/common/action.c ****     }
  68:./tmk_core/common/action.c ****     fauxclicky_check();
  69:./tmk_core/common/action.c **** #endif
  70:./tmk_core/common/action.c **** 
  71:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:./tmk_core/common/action.c ****         process_hand_swap(&event);
  74:./tmk_core/common/action.c ****     }
  75:./tmk_core/common/action.c **** #endif
  76:./tmk_core/common/action.c **** 
  77:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 77 0
  49 001e 1E82      		std Y+6,__zero_reg__
  50 0020 1D82      		std Y+5,__zero_reg__
  51 0022 85E0      		ldi r24,lo8(5)
  52 0024 FE01      		movw r30,r28
  53 0026 3796      		adiw r30,7
  54 0028 DE01      		movw r26,r28
  55 002a 1196      		adiw r26,1
  56               		0:
  57 002c 0190      		ld r0,Z+
  58 002e 0D92      		st X+,r0
  59 0030 8A95      		dec r24
  60 0032 01F4      		brne 0b
  78:./tmk_core/common/action.c **** 
  79:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:./tmk_core/common/action.c ****     }
  83:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:./tmk_core/common/action.c ****         clear_oneshot_mods();
  85:./tmk_core/common/action.c ****     }
  86:./tmk_core/common/action.c **** #endif
  87:./tmk_core/common/action.c **** 
  88:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:./tmk_core/common/action.c ****     action_tapping_process(record);
  61               		.loc 1 89 0
  62 0034 4981      		ldd r20,Y+1
  63               	.LVL1:
  64 0036 5A81      		ldd r21,Y+2
  65               	.LVL2:
  66 0038 6B81      		ldd r22,Y+3
  67 003a 7C81      		ldd r23,Y+4
  68 003c 8D81      		ldd r24,Y+5
  69 003e 9E81      		ldd r25,Y+6
  70               	/* epilogue start */
  90:./tmk_core/common/action.c **** #else
  91:./tmk_core/common/action.c ****     process_record(&record);
  92:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:./tmk_core/common/action.c ****     }
  95:./tmk_core/common/action.c **** #endif
  96:./tmk_core/common/action.c **** }
  71               		.loc 1 96 0
  72 0040 2B96      		adiw r28,11
  73 0042 0FB6      		in __tmp_reg__,__SREG__
  74 0044 F894      		cli
  75 0046 DEBF      		out __SP_H__,r29
  76 0048 0FBE      		out __SREG__,__tmp_reg__
  77 004a CDBF      		out __SP_L__,r28
  78 004c DF91      		pop r29
  79 004e CF91      		pop r28
  89:./tmk_core/common/action.c **** #else
  80               		.loc 1 89 0
  81 0050 0C94 0000 		jmp action_tapping_process
  82               	.LVL3:
  83               		.cfi_endproc
  84               	.LFE13:
  86               		.section	.text.process_record_quantum,"ax",@progbits
  87               		.weak	process_record_quantum
  89               	process_record_quantum:
  90               	.LFB15:
  97:./tmk_core/common/action.c **** 
  98:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:./tmk_core/common/action.c **** bool swap_hands = false;
 100:./tmk_core/common/action.c **** bool swap_held = false;
 101:./tmk_core/common/action.c **** 
 102:./tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:./tmk_core/common/action.c ****  *
 104:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:./tmk_core/common/action.c ****  */
 106:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:./tmk_core/common/action.c **** 
 109:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c ****     if (do_swap) {
 115:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:./tmk_core/common/action.c ****     } else {
 118:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:./tmk_core/common/action.c ****     }
 120:./tmk_core/common/action.c **** }
 121:./tmk_core/common/action.c **** #endif
 122:./tmk_core/common/action.c **** 
 123:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:./tmk_core/common/action.c **** bool disable_action_cache = false;
 125:./tmk_core/common/action.c **** 
 126:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:./tmk_core/common/action.c **** {
 128:./tmk_core/common/action.c ****     disable_action_cache = true;
 129:./tmk_core/common/action.c ****     process_record(record);
 130:./tmk_core/common/action.c ****     disable_action_cache = false;
 131:./tmk_core/common/action.c **** }
 132:./tmk_core/common/action.c **** #else
 133:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:./tmk_core/common/action.c **** {
 135:./tmk_core/common/action.c ****     process_record(record);
 136:./tmk_core/common/action.c **** }
 137:./tmk_core/common/action.c **** #endif
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c **** __attribute__ ((weak))
 140:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  91               		.loc 1 140 0
  92               		.cfi_startproc
  93               	.LVL4:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
 141:./tmk_core/common/action.c ****     return true;
 142:./tmk_core/common/action.c **** }
  98               		.loc 1 142 0
  99 0000 81E0      		ldi r24,lo8(1)
 100               	.LVL5:
 101               	/* epilogue start */
 102 0002 0895      		ret
 103               		.cfi_endproc
 104               	.LFE15:
 106               		.section	.text.process_record_tap_hint,"ax",@progbits
 107               	.global	process_record_tap_hint
 109               	process_record_tap_hint:
 110               	.LFB16:
 143:./tmk_core/common/action.c **** 
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:./tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:./tmk_core/common/action.c ****  *
 147:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:./tmk_core/common/action.c ****  */
 149:./tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:./tmk_core/common/action.c **** {
 111               		.loc 1 150 0
 112               		.cfi_startproc
 113               	.LVL6:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
 151:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 118               		.loc 1 151 0
 119 0000 FC01      		movw r30,r24
 120 0002 8081      		ld r24,Z
 121 0004 9181      		ldd r25,Z+1
 122               	.LVL7:
 123 0006 0C94 0000 		jmp layer_switch_get_action
 124               	.LVL8:
 125               		.cfi_endproc
 126               	.LFE16:
 128               		.section	.text.register_code,"ax",@progbits
 129               	.global	register_code
 131               	register_code:
 132               	.LFB19:
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c ****     switch (action.kind.id) {
 154:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:./tmk_core/common/action.c ****             switch (action.swap.code) {
 157:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:./tmk_core/common/action.c ****                 default:
 159:./tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:./tmk_core/common/action.c ****                     swap_held = true;
 161:./tmk_core/common/action.c ****             }
 162:./tmk_core/common/action.c ****             break;
 163:./tmk_core/common/action.c **** #endif
 164:./tmk_core/common/action.c ****     }
 165:./tmk_core/common/action.c **** }
 166:./tmk_core/common/action.c **** #endif
 167:./tmk_core/common/action.c **** 
 168:./tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:./tmk_core/common/action.c ****  *
 170:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:./tmk_core/common/action.c ****  */
 172:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:./tmk_core/common/action.c **** {
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:./tmk_core/common/action.c **** 
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:./tmk_core/common/action.c ****         return;
 178:./tmk_core/common/action.c **** 
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:./tmk_core/common/action.c **** #endif
 185:./tmk_core/common/action.c ****     dprintln();
 186:./tmk_core/common/action.c **** 
 187:./tmk_core/common/action.c ****     process_action(record, action);
 188:./tmk_core/common/action.c **** }
 189:./tmk_core/common/action.c **** 
 190:./tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:./tmk_core/common/action.c ****  *
 192:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:./tmk_core/common/action.c ****  */
 194:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:./tmk_core/common/action.c **** {
 196:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:./tmk_core/common/action.c **** #endif
 200:./tmk_core/common/action.c **** 
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 202:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 204:./tmk_core/common/action.c ****     }
 205:./tmk_core/common/action.c **** 
 206:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:./tmk_core/common/action.c ****     }
 213:./tmk_core/common/action.c **** #endif
 214:./tmk_core/common/action.c **** 
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 216:./tmk_core/common/action.c ****         /* Key and Mods */
 217:./tmk_core/common/action.c ****         case ACT_LMODS:
 218:./tmk_core/common/action.c ****         case ACT_RMODS:
 219:./tmk_core/common/action.c ****             {
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 223:./tmk_core/common/action.c ****                     if (mods) {
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 229:./tmk_core/common/action.c ****                         } else {
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:./tmk_core/common/action.c ****                         }
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 233:./tmk_core/common/action.c ****                     }
 234:./tmk_core/common/action.c ****                     register_code(action.key.code);
 235:./tmk_core/common/action.c ****                 } else {
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:./tmk_core/common/action.c ****                     if (mods) {
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 240:./tmk_core/common/action.c ****                         } else {
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:./tmk_core/common/action.c ****                         }
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 244:./tmk_core/common/action.c ****                     }
 245:./tmk_core/common/action.c ****                 }
 246:./tmk_core/common/action.c ****             }
 247:./tmk_core/common/action.c ****             break;
 248:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:./tmk_core/common/action.c ****             {
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:./tmk_core/common/action.c ****                         // Oneshot modifier
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:./tmk_core/common/action.c ****                                 register_mods(mods);
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods);
 265:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:./tmk_core/common/action.c ****                                 register_mods(mods);
 271:./tmk_core/common/action.c ****                     #endif
 272:./tmk_core/common/action.c ****                             } else {
 273:./tmk_core/common/action.c ****                                 register_mods(mods);
 274:./tmk_core/common/action.c ****                             }
 275:./tmk_core/common/action.c ****                         } else {
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:./tmk_core/common/action.c ****                                 }
 287:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:./tmk_core/common/action.c ****                     #endif
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****     #endif
 297:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:./tmk_core/common/action.c ****                                 register_mods(mods);
 301:./tmk_core/common/action.c ****                             }
 302:./tmk_core/common/action.c ****                         } else {
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:./tmk_core/common/action.c ****                             }
 306:./tmk_core/common/action.c ****                         }
 307:./tmk_core/common/action.c ****                         break;
 308:./tmk_core/common/action.c ****                     default:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:./tmk_core/common/action.c ****                                     register_mods(mods);
 317:./tmk_core/common/action.c ****                                 } else
 318:./tmk_core/common/action.c **** #endif
 319:./tmk_core/common/action.c ****                                 {
 320:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:./tmk_core/common/action.c ****                                 }
 323:./tmk_core/common/action.c ****                             } else {
 324:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:./tmk_core/common/action.c ****                                 register_mods(mods);
 326:./tmk_core/common/action.c ****                             }
 327:./tmk_core/common/action.c ****                         } else {
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:./tmk_core/common/action.c ****                             } else {
 332:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:./tmk_core/common/action.c ****                             }
 335:./tmk_core/common/action.c ****                         }
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****             }
 339:./tmk_core/common/action.c ****             break;
 340:./tmk_core/common/action.c **** #endif
 341:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:./tmk_core/common/action.c ****         /* other HID usage */
 343:./tmk_core/common/action.c ****         case ACT_USAGE:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 345:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:./tmk_core/common/action.c ****                     } else {
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 350:./tmk_core/common/action.c ****                     }
 351:./tmk_core/common/action.c ****                     break;
 352:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:./tmk_core/common/action.c ****                     } else {
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 357:./tmk_core/common/action.c ****                     }
 358:./tmk_core/common/action.c ****                     break;
 359:./tmk_core/common/action.c ****             }
 360:./tmk_core/common/action.c ****             break;
 361:./tmk_core/common/action.c **** #endif
 362:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:./tmk_core/common/action.c ****         /* Mouse key */
 364:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 367:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:./tmk_core/common/action.c ****                         break;
 370:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:./tmk_core/common/action.c ****                         break;
 373:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:./tmk_core/common/action.c ****                         break;
 376:./tmk_core/common/action.c ****                     default:
 377:./tmk_core/common/action.c ****                         break;
 378:./tmk_core/common/action.c ****                 }
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:./tmk_core/common/action.c ****                 mousekey_send();
 381:./tmk_core/common/action.c ****             } else {
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 383:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:./tmk_core/common/action.c ****                         break;
 386:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:./tmk_core/common/action.c ****                         break;
 389:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:./tmk_core/common/action.c ****                         break;
 392:./tmk_core/common/action.c ****                     default:
 393:./tmk_core/common/action.c ****                         break;
 394:./tmk_core/common/action.c ****                 }
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:./tmk_core/common/action.c ****                 mousekey_send();
 397:./tmk_core/common/action.c ****             }
 398:./tmk_core/common/action.c ****             break;
 399:./tmk_core/common/action.c **** #endif
 400:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:./tmk_core/common/action.c ****         case ACT_LAYER:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:./tmk_core/common/action.c ****                     }
 414:./tmk_core/common/action.c ****                 }
 415:./tmk_core/common/action.c ****             } else {
 416:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:./tmk_core/common/action.c ****                     }
 428:./tmk_core/common/action.c ****                 }
 429:./tmk_core/common/action.c ****             }
 430:./tmk_core/common/action.c ****             break;
 431:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:./tmk_core/common/action.c ****                     } else {
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:./tmk_core/common/action.c ****                     }
 444:./tmk_core/common/action.c ****                     break;
 445:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:./tmk_core/common/action.c ****                     /* tap toggle */
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:./tmk_core/common/action.c ****                         }
 451:./tmk_core/common/action.c ****                     } else {
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:./tmk_core/common/action.c ****                         }
 455:./tmk_core/common/action.c ****                     }
 456:./tmk_core/common/action.c ****                     break;
 457:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:./tmk_core/common/action.c ****                     break;
 461:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:./tmk_core/common/action.c ****                                     layer_clear();
 468:./tmk_core/common/action.c ****                     break;
 469:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:./tmk_core/common/action.c ****                     // Oneshot modifier
 472:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:./tmk_core/common/action.c ****                     if (event.pressed) {
 475:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:./tmk_core/common/action.c ****                             break;
 480:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:./tmk_core/common/action.c ****                         }
 484:./tmk_core/common/action.c ****                     } else {
 485:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:./tmk_core/common/action.c ****                         } else {
 491:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:./tmk_core/common/action.c ****                         }
 493:./tmk_core/common/action.c ****                     }
 494:./tmk_core/common/action.c ****                 #else
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:./tmk_core/common/action.c ****                     } else {
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:./tmk_core/common/action.c ****                         }
 503:./tmk_core/common/action.c ****                     }
 504:./tmk_core/common/action.c ****                 #endif
 505:./tmk_core/common/action.c ****                     break;
 506:./tmk_core/common/action.c ****             #endif
 507:./tmk_core/common/action.c ****                 default:
 508:./tmk_core/common/action.c ****                     /* tap key */
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:./tmk_core/common/action.c ****                         } else {
 514:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:./tmk_core/common/action.c ****                         }
 517:./tmk_core/common/action.c ****                     } else {
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:./tmk_core/common/action.c ****                                 wait_ms(80);
 522:./tmk_core/common/action.c ****                             }
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:./tmk_core/common/action.c ****                         } else {
 525:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:./tmk_core/common/action.c ****                         }
 528:./tmk_core/common/action.c ****                     }
 529:./tmk_core/common/action.c ****                     break;
 530:./tmk_core/common/action.c ****             }
 531:./tmk_core/common/action.c ****             break;
 532:./tmk_core/common/action.c ****     #endif
 533:./tmk_core/common/action.c **** #endif
 534:./tmk_core/common/action.c ****         /* Extentions */
 535:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:./tmk_core/common/action.c ****         case ACT_MACRO:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:./tmk_core/common/action.c ****             break;
 539:./tmk_core/common/action.c **** #endif
 540:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:./tmk_core/common/action.c ****             if (!event.pressed) {
 543:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:./tmk_core/common/action.c ****                         backlight_increase();
 546:./tmk_core/common/action.c ****                         break;
 547:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:./tmk_core/common/action.c ****                         backlight_decrease();
 549:./tmk_core/common/action.c ****                         break;
 550:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:./tmk_core/common/action.c ****                         backlight_toggle();
 552:./tmk_core/common/action.c ****                         break;
 553:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:./tmk_core/common/action.c ****                         backlight_step();
 555:./tmk_core/common/action.c ****                         break;
 556:./tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:./tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:./tmk_core/common/action.c ****                         break;
 559:./tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:./tmk_core/common/action.c ****                         backlight_level(0);
 561:./tmk_core/common/action.c ****                         break;
 562:./tmk_core/common/action.c ****                 }
 563:./tmk_core/common/action.c ****             }
 564:./tmk_core/common/action.c ****             break;
 565:./tmk_core/common/action.c **** #endif
 566:./tmk_core/common/action.c ****         case ACT_COMMAND:
 567:./tmk_core/common/action.c ****             break;
 568:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:./tmk_core/common/action.c ****             switch (action.swap.code) {
 571:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:./tmk_core/common/action.c ****                     if (event.pressed) {
 573:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:./tmk_core/common/action.c ****                     }
 575:./tmk_core/common/action.c ****                     break;
 576:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:./tmk_core/common/action.c ****                     break;
 579:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:./tmk_core/common/action.c ****                     break;
 582:./tmk_core/common/action.c ****                 case OP_SH_ON:
 583:./tmk_core/common/action.c ****                     if (!event.pressed) {
 584:./tmk_core/common/action.c ****                         swap_hands = true;
 585:./tmk_core/common/action.c ****                     }
 586:./tmk_core/common/action.c ****                     break;
 587:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:./tmk_core/common/action.c ****                     if (!event.pressed) {
 589:./tmk_core/common/action.c ****                         swap_hands = false;
 590:./tmk_core/common/action.c ****                     }
 591:./tmk_core/common/action.c ****                     break;
 592:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:./tmk_core/common/action.c ****                     /* tap toggle */
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c ****                     if (event.pressed) {
 597:./tmk_core/common/action.c ****                         if (swap_held) {
 598:./tmk_core/common/action.c ****                             swap_held = false;
 599:./tmk_core/common/action.c ****                         } else {
 600:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:./tmk_core/common/action.c ****                         }
 602:./tmk_core/common/action.c ****                     } else {
 603:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:./tmk_core/common/action.c ****                         }
 606:./tmk_core/common/action.c ****                     }
 607:./tmk_core/common/action.c ****                     break;
 608:./tmk_core/common/action.c ****                 default:
 609:./tmk_core/common/action.c ****                     /* tap key */
 610:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:./tmk_core/common/action.c ****                         if (swap_held) {
 612:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:./tmk_core/common/action.c ****                             swap_held = false;
 614:./tmk_core/common/action.c ****                         }
 615:./tmk_core/common/action.c ****                         if (event.pressed) {
 616:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:./tmk_core/common/action.c ****                         } else {
 618:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:./tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:./tmk_core/common/action.c ****                         }
 621:./tmk_core/common/action.c ****                     } else {
 622:./tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:./tmk_core/common/action.c ****                             swap_held = false;
 625:./tmk_core/common/action.c ****                         }
 626:./tmk_core/common/action.c ****                     }
 627:./tmk_core/common/action.c ****     #endif
 628:./tmk_core/common/action.c ****             }
 629:./tmk_core/common/action.c **** #endif
 630:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:./tmk_core/common/action.c ****             break;
 634:./tmk_core/common/action.c **** #endif
 635:./tmk_core/common/action.c ****         default:
 636:./tmk_core/common/action.c ****             break;
 637:./tmk_core/common/action.c ****     }
 638:./tmk_core/common/action.c **** 
 639:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 642:./tmk_core/common/action.c ****         case ACT_LAYER:
 643:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:./tmk_core/common/action.c ****         #endif
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:./tmk_core/common/action.c ****             break;
 649:./tmk_core/common/action.c ****         default:
 650:./tmk_core/common/action.c ****             break;
 651:./tmk_core/common/action.c ****     }
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c **** 
 654:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:./tmk_core/common/action.c ****   } else {
 659:./tmk_core/common/action.c ****     if (event.pressed) {
 660:./tmk_core/common/action.c ****         if (tap_count > 0) {
 661:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:./tmk_core/common/action.c ****         } else {
 663:./tmk_core/common/action.c **** 
 664:./tmk_core/common/action.c ****         }
 665:./tmk_core/common/action.c ****     } else {
 666:./tmk_core/common/action.c ****       if (tap_count > 0) {
 667:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:./tmk_core/common/action.c ****       } else {
 669:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:./tmk_core/common/action.c ****         }
 673:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:./tmk_core/common/action.c ****       }
 675:./tmk_core/common/action.c ****     }
 676:./tmk_core/common/action.c ****   }
 677:./tmk_core/common/action.c ****   #endif
 678:./tmk_core/common/action.c **** #endif
 679:./tmk_core/common/action.c **** 
 680:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:./tmk_core/common/action.c ****      */
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:./tmk_core/common/action.c ****         process_record(record);
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:./tmk_core/common/action.c ****     }
 690:./tmk_core/common/action.c **** #endif
 691:./tmk_core/common/action.c **** }
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c **** 
 694:./tmk_core/common/action.c **** 
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:./tmk_core/common/action.c ****  *
 698:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:./tmk_core/common/action.c ****  */
 700:./tmk_core/common/action.c **** void register_code(uint8_t code)
 701:./tmk_core/common/action.c **** {
 133               		.loc 1 701 0
 134               		.cfi_startproc
 135               	.LVL9:
 136 0000 CF93      		push r28
 137               	.LCFI4:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 28, -2
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 1 */
 143               	.L__stack_usage = 1
 144 0002 C82F      		mov r28,r24
 702:./tmk_core/common/action.c ****     if (code == KC_NO) {
 145               		.loc 1 702 0
 146 0004 8823      		tst r24
 147 0006 01F4      		brne .+2
 148 0008 00C0      		rjmp .L4
 703:./tmk_core/common/action.c ****         return;
 704:./tmk_core/common/action.c ****     }
 705:./tmk_core/common/action.c **** 
 706:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 149               		.loc 1 707 0
 150 000a 8238      		cpi r24,lo8(-126)
 151 000c 01F4      		brne .L7
 708:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 152               		.loc 1 710 0
 153 000e 0E94 0000 		call host_keyboard_leds
 154               	.LVL10:
 155 0012 81FD      		sbrc r24,1
 156 0014 00C0      		rjmp .L4
 711:./tmk_core/common/action.c **** #endif
 712:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 157               		.loc 1 712 0
 158 0016 89E3      		ldi r24,lo8(57)
 159 0018 0E94 0000 		call add_key
 160               	.LVL11:
 713:./tmk_core/common/action.c ****         send_keyboard_report();
 161               		.loc 1 713 0
 162 001c 0E94 0000 		call send_keyboard_report
 163               	.LVL12:
 164               	.LBB14:
 165               	.LBB15:
 166               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 167               		.loc 2 187 0
 168 0020 2FEF      		ldi r18,lo8(319999)
 169 0022 81EE      		ldi r24,hi8(319999)
 170 0024 94E0      		ldi r25,hlo8(319999)
 171 0026 2150      	1:	subi r18,1
 172 0028 8040      		sbci r24,0
 173 002a 9040      		sbci r25,0
 174 002c 01F4      		brne 1b
 175 002e 00C0      		rjmp .
 176 0030 0000      		nop
 177               	.LVL13:
 178               	.LBE15:
 179               	.LBE14:
 714:./tmk_core/common/action.c ****         wait_ms(100);
 715:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 180               		.loc 1 715 0
 181 0032 89E3      		ldi r24,lo8(57)
 182               	.L39:
 716:./tmk_core/common/action.c ****         send_keyboard_report();
 717:./tmk_core/common/action.c ****     }
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 720:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 722:./tmk_core/common/action.c **** #endif
 723:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:./tmk_core/common/action.c ****         send_keyboard_report();
 725:./tmk_core/common/action.c ****         wait_ms(100);
 726:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 183               		.loc 1 726 0
 184 0034 0E94 0000 		call del_key
 185               	.LVL14:
 186               	.L40:
 187               	/* epilogue start */
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 728:./tmk_core/common/action.c ****     }
 729:./tmk_core/common/action.c **** 
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:./tmk_core/common/action.c **** #endif
 734:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 736:./tmk_core/common/action.c ****         wait_ms(100);
 737:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:./tmk_core/common/action.c ****         send_keyboard_report();
 739:./tmk_core/common/action.c ****     }
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c **** 
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:./tmk_core/common/action.c **** 
 746:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:./tmk_core/common/action.c **** /* TODO: remove
 748:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:./tmk_core/common/action.c **** 
 752:./tmk_core/common/action.c ****             add_key(code);
 753:./tmk_core/common/action.c ****             send_keyboard_report();
 754:./tmk_core/common/action.c **** 
 755:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:./tmk_core/common/action.c ****             send_keyboard_report();
 757:./tmk_core/common/action.c ****             oneshot_cancel();
 758:./tmk_core/common/action.c ****         } else
 759:./tmk_core/common/action.c **** */
 760:./tmk_core/common/action.c **** #endif
 761:./tmk_core/common/action.c ****         {
 762:./tmk_core/common/action.c ****             add_key(code);
 763:./tmk_core/common/action.c ****             send_keyboard_report();
 764:./tmk_core/common/action.c ****         }
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:./tmk_core/common/action.c ****         send_keyboard_report();
 769:./tmk_core/common/action.c ****     }
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:./tmk_core/common/action.c ****     }
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:./tmk_core/common/action.c ****     }
 776:./tmk_core/common/action.c **** }
 188               		.loc 1 776 0
 189 0038 CF91      		pop r28
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 190               		.loc 1 727 0
 191 003a 0C94 0000 		jmp send_keyboard_report
 192               	.LVL15:
 193               	.L7:
 719:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 194               		.loc 1 719 0
 195 003e 8338      		cpi r24,lo8(-125)
 196 0040 01F4      		brne .L9
 721:./tmk_core/common/action.c **** #endif
 197               		.loc 1 721 0
 198 0042 0E94 0000 		call host_keyboard_leds
 199               	.LVL16:
 200 0046 80FD      		sbrc r24,0
 201 0048 00C0      		rjmp .L4
 723:./tmk_core/common/action.c ****         send_keyboard_report();
 202               		.loc 1 723 0
 203 004a 83E5      		ldi r24,lo8(83)
 204 004c 0E94 0000 		call add_key
 205               	.LVL17:
 724:./tmk_core/common/action.c ****         wait_ms(100);
 206               		.loc 1 724 0
 207 0050 0E94 0000 		call send_keyboard_report
 208               	.LVL18:
 209               	.LBB16:
 210               	.LBB17:
 211               		.loc 2 187 0
 212 0054 2FEF      		ldi r18,lo8(319999)
 213 0056 81EE      		ldi r24,hi8(319999)
 214 0058 94E0      		ldi r25,hlo8(319999)
 215 005a 2150      	1:	subi r18,1
 216 005c 8040      		sbci r24,0
 217 005e 9040      		sbci r25,0
 218 0060 01F4      		brne 1b
 219 0062 00C0      		rjmp .
 220 0064 0000      		nop
 221               	.LVL19:
 222               	.LBE17:
 223               	.LBE16:
 726:./tmk_core/common/action.c ****         send_keyboard_report();
 224               		.loc 1 726 0
 225 0066 83E5      		ldi r24,lo8(83)
 226 0068 00C0      		rjmp .L39
 227               	.LVL20:
 228               	.L9:
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 229               		.loc 1 730 0
 230 006a 8438      		cpi r24,lo8(-124)
 231 006c 01F4      		brne .L10
 732:./tmk_core/common/action.c **** #endif
 232               		.loc 1 732 0
 233 006e 0E94 0000 		call host_keyboard_leds
 234               	.LVL21:
 235 0072 82FD      		sbrc r24,2
 236 0074 00C0      		rjmp .L4
 734:./tmk_core/common/action.c ****         send_keyboard_report();
 237               		.loc 1 734 0
 238 0076 87E4      		ldi r24,lo8(71)
 239 0078 0E94 0000 		call add_key
 240               	.LVL22:
 735:./tmk_core/common/action.c ****         wait_ms(100);
 241               		.loc 1 735 0
 242 007c 0E94 0000 		call send_keyboard_report
 243               	.LVL23:
 244               	.LBB18:
 245               	.LBB19:
 246               		.loc 2 187 0
 247 0080 2FEF      		ldi r18,lo8(319999)
 248 0082 81EE      		ldi r24,hi8(319999)
 249 0084 94E0      		ldi r25,hlo8(319999)
 250 0086 2150      	1:	subi r18,1
 251 0088 8040      		sbci r24,0
 252 008a 9040      		sbci r25,0
 253 008c 01F4      		brne 1b
 254 008e 00C0      		rjmp .
 255 0090 0000      		nop
 256               	.LVL24:
 257               	.LBE19:
 258               	.LBE18:
 737:./tmk_core/common/action.c ****         send_keyboard_report();
 259               		.loc 1 737 0
 260 0092 87E4      		ldi r24,lo8(71)
 261 0094 00C0      		rjmp .L39
 262               	.LVL25:
 263               	.L10:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 264               		.loc 1 742 0
 265 0096 8CEF      		ldi r24,lo8(-4)
 266               	.LVL26:
 267 0098 8C0F      		add r24,r28
 268 009a 813A      		cpi r24,lo8(-95)
 269 009c 00F4      		brsh .L11
 744:./tmk_core/common/action.c **** 
 270               		.loc 1 744 0
 271 009e 8C2F      		mov r24,r28
 272 00a0 0E94 0000 		call command_proc
 273               	.LVL27:
 274 00a4 8111      		cpse r24,__zero_reg__
 275 00a6 00C0      		rjmp .L4
 762:./tmk_core/common/action.c ****             send_keyboard_report();
 276               		.loc 1 762 0
 277 00a8 8C2F      		mov r24,r28
 278 00aa 0E94 0000 		call add_key
 279               	.LVL28:
 280 00ae 00C0      		rjmp .L40
 281               	.L11:
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 282               		.loc 1 766 0
 283 00b0 80E2      		ldi r24,lo8(32)
 284 00b2 8C0F      		add r24,r28
 285 00b4 8830      		cpi r24,lo8(8)
 286 00b6 00F4      		brsh .L12
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 287               		.loc 1 767 0
 288 00b8 C770      		andi r28,lo8(7)
 289               	.LVL29:
 290 00ba 81E0      		ldi r24,lo8(1)
 291 00bc 00C0      		rjmp 2f
 292               		1:
 293 00be 880F      		lsl r24
 294               		2:
 295 00c0 CA95      		dec r28
 296 00c2 02F4      		brpl 1b
 297 00c4 0E94 0000 		call add_mods
 298               	.LVL30:
 299 00c8 00C0      		rjmp .L40
 300               	.LVL31:
 301               	.L12:
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 302               		.loc 1 770 0
 303 00ca 8BE5      		ldi r24,lo8(91)
 304 00cc 8C0F      		add r24,r28
 305 00ce 8330      		cpi r24,lo8(3)
 306 00d0 00F4      		brsh .L13
 771:./tmk_core/common/action.c ****     }
 307               		.loc 1 771 0
 308 00d2 81E8      		ldi r24,lo8(-127)
 309 00d4 90E0      		ldi r25,0
 310 00d6 C53A      		cpi r28,lo8(-91)
 311 00d8 01F0      		breq .L14
 771:./tmk_core/common/action.c ****     }
 312               		.loc 1 771 0 is_stmt 0 discriminator 1
 313 00da 83E8      		ldi r24,lo8(-125)
 314 00dc 90E0      		ldi r25,0
 315 00de C63A      		cpi r28,lo8(-90)
 316 00e0 01F4      		brne .L14
 771:./tmk_core/common/action.c ****     }
 317               		.loc 1 771 0
 318 00e2 82E8      		ldi r24,lo8(-126)
 319 00e4 90E0      		ldi r25,0
 320               	.L14:
 321               	/* epilogue start */
 322               		.loc 1 776 0 is_stmt 1 discriminator 12
 323 00e6 CF91      		pop r28
 324               	.LVL32:
 771:./tmk_core/common/action.c ****     }
 325               		.loc 1 771 0 discriminator 12
 326 00e8 0C94 0000 		jmp host_system_send
 327               	.LVL33:
 328               	.L13:
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 329               		.loc 1 773 0
 330 00ec 88E5      		ldi r24,lo8(88)
 331 00ee 8C0F      		add r24,r28
 332 00f0 8531      		cpi r24,lo8(21)
 333 00f2 00F0      		brlo .+2
 334 00f4 00C0      		rjmp .L4
 774:./tmk_core/common/action.c ****     }
 335               		.loc 1 774 0
 336 00f6 82EE      		ldi r24,lo8(-30)
 337 00f8 90E0      		ldi r25,0
 338 00fa C83A      		cpi r28,lo8(-88)
 339 00fc 01F4      		brne .+2
 340 00fe 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 341               		.loc 1 774 0 is_stmt 0 discriminator 1
 342 0100 89EE      		ldi r24,lo8(-23)
 343 0102 90E0      		ldi r25,0
 344 0104 C93A      		cpi r28,lo8(-87)
 345 0106 01F4      		brne .+2
 346 0108 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 347               		.loc 1 774 0 discriminator 3
 348 010a 8AEE      		ldi r24,lo8(-22)
 349 010c 90E0      		ldi r25,0
 350 010e CA3A      		cpi r28,lo8(-86)
 351 0110 01F4      		brne .+2
 352 0112 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 353               		.loc 1 774 0 discriminator 5
 354 0114 85EB      		ldi r24,lo8(-75)
 355 0116 90E0      		ldi r25,0
 356 0118 CB3A      		cpi r28,lo8(-85)
 357 011a 01F4      		brne .+2
 358 011c 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 359               		.loc 1 774 0 discriminator 7
 360 011e 86EB      		ldi r24,lo8(-74)
 361 0120 90E0      		ldi r25,0
 362 0122 CC3A      		cpi r28,lo8(-84)
 363 0124 01F4      		brne .+2
 364 0126 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 365               		.loc 1 774 0 discriminator 9
 366 0128 83EB      		ldi r24,lo8(-77)
 367 012a 90E0      		ldi r25,0
 368 012c CB3B      		cpi r28,lo8(-69)
 369 012e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 370               		.loc 1 774 0 discriminator 11
 371 0130 84EB      		ldi r24,lo8(-76)
 372 0132 90E0      		ldi r25,0
 373 0134 CC3B      		cpi r28,lo8(-68)
 374 0136 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 375               		.loc 1 774 0 discriminator 13
 376 0138 87EB      		ldi r24,lo8(-73)
 377 013a 90E0      		ldi r25,0
 378 013c CD3A      		cpi r28,lo8(-83)
 379 013e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 380               		.loc 1 774 0 discriminator 15
 381 0140 8CEC      		ldi r24,lo8(-52)
 382 0142 90E0      		ldi r25,0
 383 0144 C03B      		cpi r28,lo8(-80)
 384 0146 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 385               		.loc 1 774 0 discriminator 17
 386 0148 8DEC      		ldi r24,lo8(-51)
 387 014a 90E0      		ldi r25,0
 388 014c CE3A      		cpi r28,lo8(-82)
 389 014e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 390               		.loc 1 774 0 discriminator 19
 391 0150 83E8      		ldi r24,lo8(-125)
 392 0152 91E0      		ldi r25,lo8(1)
 393 0154 CF3A      		cpi r28,lo8(-81)
 394 0156 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 395               		.loc 1 774 0 discriminator 21
 396 0158 8AE8      		ldi r24,lo8(-118)
 397 015a 91E0      		ldi r25,lo8(1)
 398 015c C13B      		cpi r28,lo8(-79)
 399 015e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 400               		.loc 1 774 0 discriminator 23
 401 0160 82E9      		ldi r24,lo8(-110)
 402 0162 91E0      		ldi r25,lo8(1)
 403 0164 C23B      		cpi r28,lo8(-78)
 404 0166 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 405               		.loc 1 774 0 discriminator 25
 406 0168 84E9      		ldi r24,lo8(-108)
 407 016a 91E0      		ldi r25,lo8(1)
 408 016c C33B      		cpi r28,lo8(-77)
 409 016e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 410               		.loc 1 774 0 discriminator 27
 411 0170 81E2      		ldi r24,lo8(33)
 412 0172 92E0      		ldi r25,lo8(2)
 413 0174 C43B      		cpi r28,lo8(-76)
 414 0176 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 415               		.loc 1 774 0 discriminator 29
 416 0178 83E2      		ldi r24,lo8(35)
 417 017a 92E0      		ldi r25,lo8(2)
 418 017c C53B      		cpi r28,lo8(-75)
 419 017e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 420               		.loc 1 774 0 discriminator 31
 421 0180 84E2      		ldi r24,lo8(36)
 422 0182 92E0      		ldi r25,lo8(2)
 423 0184 C63B      		cpi r28,lo8(-74)
 424 0186 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 425               		.loc 1 774 0 discriminator 33
 426 0188 85E2      		ldi r24,lo8(37)
 427 018a 92E0      		ldi r25,lo8(2)
 428 018c C73B      		cpi r28,lo8(-73)
 429 018e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 430               		.loc 1 774 0 discriminator 35
 431 0190 86E2      		ldi r24,lo8(38)
 432 0192 92E0      		ldi r25,lo8(2)
 433 0194 C83B      		cpi r28,lo8(-72)
 434 0196 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 435               		.loc 1 774 0 discriminator 37
 436 0198 87E2      		ldi r24,lo8(39)
 437 019a 92E0      		ldi r25,lo8(2)
 438 019c C93B      		cpi r28,lo8(-71)
 439 019e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 440               		.loc 1 774 0 discriminator 39
 441 01a0 90E0      		ldi r25,0
 442 01a2 80E0      		ldi r24,0
 443 01a4 CA3B      		cpi r28,lo8(-70)
 444 01a6 01F4      		brne .L15
 774:./tmk_core/common/action.c ****     }
 445               		.loc 1 774 0
 446 01a8 8AE2      		ldi r24,lo8(42)
 447 01aa 92E0      		ldi r25,lo8(2)
 448               	.L15:
 449               	/* epilogue start */
 450               		.loc 1 776 0 is_stmt 1 discriminator 84
 451 01ac CF91      		pop r28
 452               	.LVL34:
 774:./tmk_core/common/action.c ****     }
 453               		.loc 1 774 0 discriminator 84
 454 01ae 0C94 0000 		jmp host_consumer_send
 455               	.LVL35:
 456               	.L4:
 457               	/* epilogue start */
 458               		.loc 1 776 0
 459 01b2 CF91      		pop r28
 460               	.LVL36:
 461 01b4 0895      		ret
 462               		.cfi_endproc
 463               	.LFE19:
 465               		.section	.text.unregister_code,"ax",@progbits
 466               	.global	unregister_code
 468               	unregister_code:
 469               	.LFB20:
 777:./tmk_core/common/action.c **** 
 778:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:./tmk_core/common/action.c ****  *
 780:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:./tmk_core/common/action.c ****  */
 782:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:./tmk_core/common/action.c **** {
 470               		.loc 1 783 0
 471               		.cfi_startproc
 472               	.LVL37:
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (code == KC_NO) {
 477               		.loc 1 784 0
 478 0000 8823      		tst r24
 479 0002 01F4      		brne .+2
 480 0004 00C0      		rjmp .L41
 785:./tmk_core/common/action.c ****         return;
 786:./tmk_core/common/action.c ****     }
 787:./tmk_core/common/action.c **** 
 788:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 481               		.loc 1 789 0
 482 0006 8238      		cpi r24,lo8(-126)
 483 0008 01F4      		brne .L44
 790:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 484               		.loc 1 792 0
 485 000a 0E94 0000 		call host_keyboard_leds
 486               	.LVL38:
 487 000e 81FF      		sbrs r24,1
 488 0010 00C0      		rjmp .L41
 793:./tmk_core/common/action.c **** #endif
 794:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 489               		.loc 1 794 0
 490 0012 89E3      		ldi r24,lo8(57)
 491 0014 0E94 0000 		call add_key
 492               	.LVL39:
 795:./tmk_core/common/action.c ****         send_keyboard_report();
 493               		.loc 1 795 0
 494 0018 0E94 0000 		call send_keyboard_report
 495               	.LVL40:
 796:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 496               		.loc 1 796 0
 497 001c 89E3      		ldi r24,lo8(57)
 498               	.L60:
 797:./tmk_core/common/action.c ****         send_keyboard_report();
 798:./tmk_core/common/action.c ****     }
 799:./tmk_core/common/action.c **** 
 800:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 803:./tmk_core/common/action.c **** #endif
 804:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:./tmk_core/common/action.c ****         send_keyboard_report();
 806:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 499               		.loc 1 806 0
 500 001e 0E94 0000 		call del_key
 501               	.LVL41:
 502               	.L61:
 807:./tmk_core/common/action.c ****         send_keyboard_report();
 503               		.loc 1 807 0
 504 0022 0C94 0000 		jmp send_keyboard_report
 505               	.LVL42:
 506               	.L44:
 800:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 507               		.loc 1 800 0
 508 0026 8338      		cpi r24,lo8(-125)
 509 0028 01F4      		brne .L46
 802:./tmk_core/common/action.c **** #endif
 510               		.loc 1 802 0
 511 002a 0E94 0000 		call host_keyboard_leds
 512               	.LVL43:
 513 002e 80FF      		sbrs r24,0
 514 0030 00C0      		rjmp .L41
 804:./tmk_core/common/action.c ****         send_keyboard_report();
 515               		.loc 1 804 0
 516 0032 83E5      		ldi r24,lo8(83)
 517 0034 0E94 0000 		call add_key
 518               	.LVL44:
 805:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 519               		.loc 1 805 0
 520 0038 0E94 0000 		call send_keyboard_report
 521               	.LVL45:
 806:./tmk_core/common/action.c ****         send_keyboard_report();
 522               		.loc 1 806 0
 523 003c 83E5      		ldi r24,lo8(83)
 524 003e 00C0      		rjmp .L60
 525               	.LVL46:
 526               	.L46:
 808:./tmk_core/common/action.c ****     }
 809:./tmk_core/common/action.c **** 
 810:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 527               		.loc 1 810 0
 528 0040 8438      		cpi r24,lo8(-124)
 529 0042 01F4      		brne .L47
 811:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 530               		.loc 1 812 0
 531 0044 0E94 0000 		call host_keyboard_leds
 532               	.LVL47:
 533 0048 82FF      		sbrs r24,2
 534 004a 00C0      		rjmp .L41
 813:./tmk_core/common/action.c **** #endif
 814:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 535               		.loc 1 814 0
 536 004c 87E4      		ldi r24,lo8(71)
 537 004e 0E94 0000 		call add_key
 538               	.LVL48:
 815:./tmk_core/common/action.c ****         send_keyboard_report();
 539               		.loc 1 815 0
 540 0052 0E94 0000 		call send_keyboard_report
 541               	.LVL49:
 816:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 542               		.loc 1 816 0
 543 0056 87E4      		ldi r24,lo8(71)
 544 0058 00C0      		rjmp .L60
 545               	.LVL50:
 546               	.L47:
 817:./tmk_core/common/action.c ****         send_keyboard_report();
 818:./tmk_core/common/action.c ****     }
 819:./tmk_core/common/action.c **** #endif
 820:./tmk_core/common/action.c **** 
 821:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 547               		.loc 1 821 0
 548 005a 9CEF      		ldi r25,lo8(-4)
 549 005c 980F      		add r25,r24
 550 005e 913A      		cpi r25,lo8(-95)
 551 0060 00F0      		brlo .L60
 822:./tmk_core/common/action.c ****         del_key(code);
 823:./tmk_core/common/action.c ****         send_keyboard_report();
 824:./tmk_core/common/action.c ****     }
 825:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 552               		.loc 1 825 0
 553 0062 90E2      		ldi r25,lo8(32)
 554 0064 980F      		add r25,r24
 555 0066 9830      		cpi r25,lo8(8)
 556 0068 00F4      		brsh .L49
 826:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 557               		.loc 1 826 0
 558 006a 8770      		andi r24,lo8(7)
 559               	.LVL51:
 560 006c 91E0      		ldi r25,lo8(1)
 561 006e 00C0      		rjmp 2f
 562               		1:
 563 0070 990F      		lsl r25
 564               		2:
 565 0072 8A95      		dec r24
 566 0074 02F4      		brpl 1b
 567 0076 892F      		mov r24,r25
 568 0078 0E94 0000 		call del_mods
 569               	.LVL52:
 570 007c 00C0      		rjmp .L61
 571               	.LVL53:
 572               	.L49:
 827:./tmk_core/common/action.c ****         send_keyboard_report();
 828:./tmk_core/common/action.c ****     }
 829:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 573               		.loc 1 829 0
 574 007e 9BE5      		ldi r25,lo8(91)
 575 0080 980F      		add r25,r24
 576 0082 9330      		cpi r25,lo8(3)
 577 0084 00F4      		brsh .L50
 830:./tmk_core/common/action.c ****         host_system_send(0);
 578               		.loc 1 830 0
 579 0086 90E0      		ldi r25,0
 580 0088 80E0      		ldi r24,0
 581               	.LVL54:
 582 008a 0C94 0000 		jmp host_system_send
 583               	.LVL55:
 584               	.L50:
 831:./tmk_core/common/action.c ****     }
 832:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 585               		.loc 1 832 0
 586 008e 885A      		subi r24,lo8(-(88))
 587               	.LVL56:
 588 0090 8531      		cpi r24,lo8(21)
 589 0092 00F4      		brsh .L41
 833:./tmk_core/common/action.c ****         host_consumer_send(0);
 590               		.loc 1 833 0
 591 0094 90E0      		ldi r25,0
 592 0096 80E0      		ldi r24,0
 593               	.LVL57:
 594 0098 0C94 0000 		jmp host_consumer_send
 595               	.LVL58:
 596               	.L41:
 597               	/* epilogue start */
 834:./tmk_core/common/action.c ****     }
 835:./tmk_core/common/action.c **** }
 598               		.loc 1 835 0
 599 009c 0895      		ret
 600               		.cfi_endproc
 601               	.LFE20:
 603               		.section	.text.register_mods,"ax",@progbits
 604               	.global	register_mods
 606               	register_mods:
 607               	.LFB21:
 836:./tmk_core/common/action.c **** 
 837:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:./tmk_core/common/action.c ****  *
 839:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:./tmk_core/common/action.c ****  */
 841:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:./tmk_core/common/action.c **** {
 608               		.loc 1 842 0
 609               		.cfi_startproc
 610               	.LVL59:
 611               	/* prologue: function */
 612               	/* frame size = 0 */
 613               	/* stack size = 0 */
 614               	.L__stack_usage = 0
 843:./tmk_core/common/action.c ****     if (mods) {
 615               		.loc 1 843 0
 616 0000 8823      		tst r24
 617 0002 01F0      		breq .L62
 844:./tmk_core/common/action.c ****         add_mods(mods);
 618               		.loc 1 844 0
 619 0004 0E94 0000 		call add_mods
 620               	.LVL60:
 845:./tmk_core/common/action.c ****         send_keyboard_report();
 621               		.loc 1 845 0
 622 0008 0C94 0000 		jmp send_keyboard_report
 623               	.LVL61:
 624               	.L62:
 625               	/* epilogue start */
 846:./tmk_core/common/action.c ****     }
 847:./tmk_core/common/action.c **** }
 626               		.loc 1 847 0
 627 000c 0895      		ret
 628               		.cfi_endproc
 629               	.LFE21:
 631               		.section	.text.unregister_mods,"ax",@progbits
 632               	.global	unregister_mods
 634               	unregister_mods:
 635               	.LFB22:
 848:./tmk_core/common/action.c **** 
 849:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:./tmk_core/common/action.c ****  *
 851:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:./tmk_core/common/action.c ****  */
 853:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:./tmk_core/common/action.c **** {
 636               		.loc 1 854 0
 637               		.cfi_startproc
 638               	.LVL62:
 639               	/* prologue: function */
 640               	/* frame size = 0 */
 641               	/* stack size = 0 */
 642               	.L__stack_usage = 0
 855:./tmk_core/common/action.c ****     if (mods) {
 643               		.loc 1 855 0
 644 0000 8823      		tst r24
 645 0002 01F0      		breq .L64
 856:./tmk_core/common/action.c ****         del_mods(mods);
 646               		.loc 1 856 0
 647 0004 0E94 0000 		call del_mods
 648               	.LVL63:
 857:./tmk_core/common/action.c ****         send_keyboard_report();
 649               		.loc 1 857 0
 650 0008 0C94 0000 		jmp send_keyboard_report
 651               	.LVL64:
 652               	.L64:
 653               	/* epilogue start */
 858:./tmk_core/common/action.c ****     }
 859:./tmk_core/common/action.c **** }
 654               		.loc 1 859 0
 655 000c 0895      		ret
 656               		.cfi_endproc
 657               	.LFE22:
 659               		.section	.text.process_action,"ax",@progbits
 660               	.global	process_action
 662               	process_action:
 663               	.LFB18:
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 664               		.loc 1 195 0
 665               		.cfi_startproc
 666               	.LVL65:
 667 0000 8F92      		push r8
 668               	.LCFI5:
 669               		.cfi_def_cfa_offset 3
 670               		.cfi_offset 8, -2
 671 0002 9F92      		push r9
 672               	.LCFI6:
 673               		.cfi_def_cfa_offset 4
 674               		.cfi_offset 9, -3
 675 0004 AF92      		push r10
 676               	.LCFI7:
 677               		.cfi_def_cfa_offset 5
 678               		.cfi_offset 10, -4
 679 0006 BF92      		push r11
 680               	.LCFI8:
 681               		.cfi_def_cfa_offset 6
 682               		.cfi_offset 11, -5
 683 0008 DF92      		push r13
 684               	.LCFI9:
 685               		.cfi_def_cfa_offset 7
 686               		.cfi_offset 13, -6
 687 000a EF92      		push r14
 688               	.LCFI10:
 689               		.cfi_def_cfa_offset 8
 690               		.cfi_offset 14, -7
 691 000c FF92      		push r15
 692               	.LCFI11:
 693               		.cfi_def_cfa_offset 9
 694               		.cfi_offset 15, -8
 695 000e 0F93      		push r16
 696               	.LCFI12:
 697               		.cfi_def_cfa_offset 10
 698               		.cfi_offset 16, -9
 699 0010 1F93      		push r17
 700               	.LCFI13:
 701               		.cfi_def_cfa_offset 11
 702               		.cfi_offset 17, -10
 703 0012 CF93      		push r28
 704               	.LCFI14:
 705               		.cfi_def_cfa_offset 12
 706               		.cfi_offset 28, -11
 707 0014 DF93      		push r29
 708               	.LCFI15:
 709               		.cfi_def_cfa_offset 13
 710               		.cfi_offset 29, -12
 711               	/* prologue: function */
 712               	/* frame size = 0 */
 713               	/* stack size = 11 */
 714               	.L__stack_usage = 11
 715 0016 7C01      		movw r14,r24
 716 0018 D62F      		mov r29,r22
 717 001a C72F      		mov r28,r23
 718               	.LVL66:
 198:./tmk_core/common/action.c **** #endif
 719               		.loc 1 198 0
 720 001c FC01      		movw r30,r24
 721 001e 0581      		ldd r16,Z+5
 722 0020 0295      		swap r16
 723 0022 0F70      		andi r16,lo8(15)
 724               	.LVL67:
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 725               		.loc 1 201 0
 726 0024 1281      		ldd r17,Z+2
 727 0026 1111      		cpse r17,__zero_reg__
 203:./tmk_core/common/action.c ****     }
 728               		.loc 1 203 0
 729 0028 0E94 0000 		call clear_weak_mods
 730               	.LVL68:
 731               	.L67:
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 732               		.loc 1 209 0
 733 002c 0E94 0000 		call is_oneshot_layer_active
 734               	.LVL69:
 735 0030 D82E      		mov r13,r24
 736 0032 8823      		tst r24
 737 0034 01F0      		breq .L68
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 738               		.loc 1 209 0 is_stmt 0 discriminator 1
 739 0036 1123      		tst r17
 740 0038 01F0      		breq .L155
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 741               		.loc 1 209 0 discriminator 2
 742 003a 80E2      		ldi r24,lo8(32)
 743 003c 8D0F      		add r24,r29
 744 003e 8830      		cpi r24,lo8(8)
 745 0040 00F0      		brlo .L155
 210:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 746               		.loc 1 210 0 is_stmt 1
 747 0042 82E0      		ldi r24,lo8(2)
 748 0044 0E94 0000 		call clear_oneshot_layer_state
 749               	.LVL70:
 211:./tmk_core/common/action.c ****     }
 750               		.loc 1 211 0
 751 0048 0E94 0000 		call is_oneshot_layer_active
 752               	.LVL71:
 753 004c 91E0      		ldi r25,lo8(1)
 754 004e D82E      		mov r13,r24
 755 0050 D926      		eor r13,r25
 756               	.LVL72:
 757               	.L68:
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 758               		.loc 1 215 0
 759 0052 BC2E      		mov r11,r28
 760 0054 B294      		swap r11
 761 0056 9FE0      		ldi r25,lo8(15)
 762 0058 B922      		and r11,r25
 763 005a EB2D      		mov r30,r11
 764 005c F0E0      		ldi r31,0
 765 005e E050      		subi r30,lo8(-(gs(.L71)))
 766 0060 F040      		sbci r31,hi8(-(gs(.L71)))
 767 0062 0C94 0000 		jmp __tablejump2__
 768               		.p2align	1
 769               	.L71:
 770 0066 0000      		.word gs(.L70)
 771 0068 0000      		.word gs(.L70)
 772 006a 0000      		.word gs(.L72)
 773 006c 0000      		.word gs(.L72)
 774 006e 0000      		.word gs(.L73)
 775 0070 0000      		.word gs(.L74)
 776 0072 0000      		.word gs(.L69)
 777 0074 0000      		.word gs(.L69)
 778 0076 0000      		.word gs(.L75)
 779 0078 0000      		.word gs(.L69)
 780 007a 0000      		.word gs(.L76)
 781 007c 0000      		.word gs(.L76)
 782 007e 0000      		.word gs(.L77)
 783 0080 0000      		.word gs(.L69)
 784 0082 0000      		.word gs(.L69)
 785 0084 0000      		.word gs(.L78)
 786               	.LVL73:
 787               	.L155:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 788               		.loc 1 207 0
 789 0086 D12C      		mov r13,__zero_reg__
 790 0088 00C0      		rjmp .L68
 791               	.LVL74:
 792               	.L70:
 793 008a 0C2F      		mov r16,r28
 794               	.LVL75:
 795 008c 0F70      		andi r16,lo8(15)
 796               	.LBB20:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 797               		.loc 1 220 0
 798 008e C07F      		andi r28,lo8(-16)
 799               	.LVL76:
 800 0090 01F0      		breq .L79
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 801               		.loc 1 220 0 is_stmt 0 discriminator 2
 802 0092 0295      		swap r16
 803 0094 007F      		andi r16,lo8(-16)
 804               	.L79:
 805               	.LVL77:
 222:./tmk_core/common/action.c ****                     if (mods) {
 806               		.loc 1 222 0 is_stmt 1 discriminator 4
 807 0096 1123      		tst r17
 808 0098 01F0      		breq .L80
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 809               		.loc 1 223 0
 810 009a 0023      		tst r16
 811 009c 01F0      		breq .L102
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 812               		.loc 1 224 0
 813 009e 80E2      		ldi r24,lo8(32)
 814 00a0 8D0F      		add r24,r29
 815 00a2 8830      		cpi r24,lo8(8)
 816 00a4 00F0      		brlo .L82
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 817               		.loc 1 224 0 is_stmt 0 discriminator 1
 818 00a6 D111      		cpse r29,__zero_reg__
 819 00a8 00C0      		rjmp .L83
 820               	.L82:
 228:./tmk_core/common/action.c ****                         } else {
 821               		.loc 1 228 0 is_stmt 1
 822 00aa 802F      		mov r24,r16
 823 00ac 0E94 0000 		call add_mods
 824               	.LVL78:
 825               	.L84:
 232:./tmk_core/common/action.c ****                     }
 826               		.loc 1 232 0
 827 00b0 0E94 0000 		call send_keyboard_report
 828               	.LVL79:
 829               	.L102:
 830               	.LBE20:
 831               	.LBB21:
 321:./tmk_core/common/action.c ****                                 }
 832               		.loc 1 321 0
 833 00b4 8D2F      		mov r24,r29
 834 00b6 0E94 0000 		call register_code
 835               	.LVL80:
 836 00ba 00C0      		rjmp .L85
 837               	.LVL81:
 838               	.L83:
 839               	.LBE21:
 840               	.LBB22:
 230:./tmk_core/common/action.c ****                         }
 841               		.loc 1 230 0
 842 00bc 802F      		mov r24,r16
 843 00be 0E94 0000 		call add_weak_mods
 844               	.LVL82:
 845 00c2 00C0      		rjmp .L84
 846               	.L80:
 236:./tmk_core/common/action.c ****                     if (mods) {
 847               		.loc 1 236 0
 848 00c4 8D2F      		mov r24,r29
 849 00c6 0E94 0000 		call unregister_code
 850               	.LVL83:
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 851               		.loc 1 237 0
 852 00ca 0023      		tst r16
 853 00cc 01F0      		breq .L85
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 854               		.loc 1 238 0
 855 00ce 80E2      		ldi r24,lo8(32)
 856 00d0 8D0F      		add r24,r29
 857 00d2 8830      		cpi r24,lo8(8)
 858 00d4 00F0      		brlo .L87
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 859               		.loc 1 238 0 is_stmt 0 discriminator 1
 860 00d6 D111      		cpse r29,__zero_reg__
 861 00d8 00C0      		rjmp .L88
 862               	.L87:
 239:./tmk_core/common/action.c ****                         } else {
 863               		.loc 1 239 0 is_stmt 1
 864 00da 802F      		mov r24,r16
 865 00dc 0E94 0000 		call del_mods
 866               	.LVL84:
 867               	.L89:
 243:./tmk_core/common/action.c ****                     }
 868               		.loc 1 243 0
 869 00e0 0E94 0000 		call send_keyboard_report
 870               	.LVL85:
 871               	.L85:
 872               	.LBE22:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 873               		.loc 1 684 0
 874 00e4 DD20      		tst r13
 875 00e6 01F4      		brne .+2
 876 00e8 00C0      		rjmp .L66
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 877               		.loc 1 684 0 is_stmt 0 discriminator 1
 878 00ea 0E94 0000 		call get_oneshot_layer_state
 879               	.LVL86:
 880 00ee 80FD      		sbrc r24,0
 881 00f0 00C0      		rjmp .L66
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 882               		.loc 1 685 0 is_stmt 1
 883 00f2 F701      		movw r30,r14
 884 00f4 1282      		std Z+2,__zero_reg__
 686:./tmk_core/common/action.c ****         process_record(record);
 885               		.loc 1 686 0
 886 00f6 0E94 0000 		call get_oneshot_layer
 887               	.LVL87:
 888 00fa 0E94 0000 		call layer_on
 889               	.LVL88:
 687:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 890               		.loc 1 687 0
 891 00fe C701      		movw r24,r14
 892 0100 0E94 0000 		call process_record
 893               	.LVL89:
 688:./tmk_core/common/action.c ****     }
 894               		.loc 1 688 0
 895 0104 0E94 0000 		call get_oneshot_layer
 896               	.LVL90:
 897               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 898               		.loc 1 691 0
 899 0108 DF91      		pop r29
 900               	.LVL91:
 901 010a CF91      		pop r28
 902 010c 1F91      		pop r17
 903               	.LVL92:
 904 010e 0F91      		pop r16
 905 0110 FF90      		pop r15
 906 0112 EF90      		pop r14
 907               	.LVL93:
 908 0114 DF90      		pop r13
 909               	.LVL94:
 910 0116 BF90      		pop r11
 911 0118 AF90      		pop r10
 912 011a 9F90      		pop r9
 913 011c 8F90      		pop r8
 688:./tmk_core/common/action.c ****     }
 914               		.loc 1 688 0
 915 011e 0C94 0000 		jmp layer_off
 916               	.LVL95:
 917               	.L88:
 918               	.LBB23:
 241:./tmk_core/common/action.c ****                         }
 919               		.loc 1 241 0
 920 0122 802F      		mov r24,r16
 921 0124 0E94 0000 		call del_weak_mods
 922               	.LVL96:
 923 0128 00C0      		rjmp .L89
 924               	.LVL97:
 925               	.L72:
 926 012a FC2F      		mov r31,r28
 927 012c FF70      		andi r31,lo8(15)
 928 012e BF2E      		mov r11,r31
 929               	.LBE23:
 930               	.LBB24:
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 931               		.loc 1 252 0
 932 0130 C07F      		andi r28,lo8(-16)
 933               	.LVL98:
 934 0132 C032      		cpi r28,lo8(32)
 935 0134 01F0      		breq .L90
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 936               		.loc 1 252 0 is_stmt 0 discriminator 2
 937 0136 B294      		swap r11
 938 0138 80EF      		ldi r24,lo8(-16)
 939 013a B822      		and r11,r24
 940               	.L90:
 941               	.LVL99:
 254:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 942               		.loc 1 254 0 is_stmt 1 discriminator 4
 943 013c DD23      		tst r29
 944 013e 01F0      		breq .L92
 945 0140 D130      		cpi r29,lo8(1)
 946 0142 01F0      		breq .L93
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 947               		.loc 1 309 0
 948 0144 1123      		tst r17
 949 0146 01F0      		breq .L100
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 950               		.loc 1 310 0
 951 0148 0023      		tst r16
 952 014a 01F0      		breq .L101
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 953               		.loc 1 312 0
 954 014c F701      		movw r30,r14
 955 014e 8581      		ldd r24,Z+5
 956 0150 80FF      		sbrs r24,0
 957 0152 00C0      		rjmp .L102
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 958               		.loc 1 315 0
 959 0154 8F70      		andi r24,lo8(15)
 960 0156 8583      		std Z+5,r24
 961 0158 00C0      		rjmp .L101
 962               	.L92:
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 963               		.loc 1 258 0
 964 015a 1123      		tst r17
 965 015c 01F0      		breq .L94
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 966               		.loc 1 259 0
 967 015e 0111      		cpse r16,__zero_reg__
 968 0160 00C0      		rjmp .L95
 969               	.L101:
 325:./tmk_core/common/action.c ****                             }
 970               		.loc 1 325 0
 971 0162 8B2D      		mov r24,r11
 972               	.L192:
 973 0164 0E94 0000 		call register_mods
 974               	.LVL100:
 975 0168 00C0      		rjmp .L85
 976               	.L95:
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 977               		.loc 1 264 0
 978 016a 8B2D      		mov r24,r11
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 979               		.loc 1 262 0
 980 016c 0130      		cpi r16,lo8(1)
 981 016e 01F4      		brne .L192
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 982               		.loc 1 264 0
 983 0170 0E94 0000 		call set_oneshot_mods
 984               	.LVL101:
 985 0174 00C0      		rjmp .L85
 986               	.L94:
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 987               		.loc 1 276 0
 988 0176 0111      		cpse r16,__zero_reg__
 989 0178 00C0      		rjmp .L97
 990               	.L193:
 291:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 991               		.loc 1 291 0
 992 017a 0E94 0000 		call clear_oneshot_mods
 993               	.LVL102:
 994               	.L103:
 333:./tmk_core/common/action.c ****                             }
 995               		.loc 1 333 0
 996 017e 8B2D      		mov r24,r11
 997 0180 0E94 0000 		call unregister_mods
 998               	.LVL103:
 999 0184 00C0      		rjmp .L85
 1000               	.L97:
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1001               		.loc 1 279 0
 1002 0186 0130      		cpi r16,lo8(1)
 1003 0188 01F4      		brne .+2
 1004 018a 00C0      		rjmp .L85
 1005 018c 00C0      		rjmp .L193
 1006               	.L93:
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1007               		.loc 1 298 0
 1008 018e 1123      		tst r17
 1009 0190 01F0      		breq .L99
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1010               		.loc 1 299 0
 1011 0192 0630      		cpi r16,lo8(6)
 1012 0194 00F0      		brlo .+2
 1013 0196 00C0      		rjmp .L85
 1014 0198 00C0      		rjmp .L101
 1015               	.L99:
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1016               		.loc 1 303 0
 1017 019a 0530      		cpi r16,lo8(5)
 1018 019c 00F0      		brlo .+2
 1019 019e 00C0      		rjmp .L85
 1020 01a0 00C0      		rjmp .L103
 1021               	.L100:
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1022               		.loc 1 328 0
 1023 01a2 0023      		tst r16
 1024 01a4 01F0      		breq .L103
 330:./tmk_core/common/action.c ****                             } else {
 1025               		.loc 1 330 0
 1026 01a6 8D2F      		mov r24,r29
 1027 01a8 0E94 0000 		call unregister_code
 1028               	.LVL104:
 1029 01ac 00C0      		rjmp .L85
 1030               	.LVL105:
 1031               	.L73:
 1032               	.LBE24:
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1033               		.loc 1 344 0
 1034 01ae 8C2F      		mov r24,r28
 1035 01b0 8695      		lsr r24
 1036 01b2 8695      		lsr r24
 1037 01b4 8370      		andi r24,lo8(3)
 1038 01b6 01F0      		breq .L104
 1039 01b8 8130      		cpi r24,lo8(1)
 1040 01ba 01F0      		breq .L105
 1041               	.L69:
 641:./tmk_core/common/action.c ****         case ACT_LAYER:
 1042               		.loc 1 641 0
 1043 01bc 98E0      		ldi r25,lo8(8)
 1044 01be B916      		cp r11,r25
 1045 01c0 01F4      		brne .+2
 1046 01c2 00C0      		rjmp .L118
 1047 01c4 B916      		cp r11,r25
 1048 01c6 00F4      		brsh .+2
 1049 01c8 00C0      		rjmp .L85
 1050 01ca 86EF      		ldi r24,lo8(-10)
 1051 01cc 8B0D      		add r24,r11
 1052 01ce 8230      		cpi r24,lo8(2)
 1053 01d0 00F4      		brsh .+2
 1054 01d2 00C0      		rjmp .L118
 1055 01d4 00C0      		rjmp .L85
 1056               	.L104:
 347:./tmk_core/common/action.c ****                     } else {
 1057               		.loc 1 347 0
 1058 01d6 8D2F      		mov r24,r29
 1059 01d8 9C2F      		mov r25,r28
 1060 01da 9370      		andi r25,lo8(3)
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1061               		.loc 1 346 0
 1062 01dc 1111      		cpse r17,__zero_reg__
 1063 01de 00C0      		rjmp .L190
 349:./tmk_core/common/action.c ****                     }
 1064               		.loc 1 349 0
 1065 01e0 90E0      		ldi r25,0
 1066 01e2 80E0      		ldi r24,0
 1067               	.L190:
 1068 01e4 0E94 0000 		call host_system_send
 1069               	.LVL106:
 1070 01e8 00C0      		rjmp .L85
 1071               	.L105:
 354:./tmk_core/common/action.c ****                     } else {
 1072               		.loc 1 354 0
 1073 01ea 8D2F      		mov r24,r29
 1074 01ec 9C2F      		mov r25,r28
 1075 01ee 9370      		andi r25,lo8(3)
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1076               		.loc 1 353 0
 1077 01f0 1111      		cpse r17,__zero_reg__
 1078 01f2 00C0      		rjmp .L189
 356:./tmk_core/common/action.c ****                     }
 1079               		.loc 1 356 0
 1080 01f4 90E0      		ldi r25,0
 1081 01f6 80E0      		ldi r24,0
 1082               	.L189:
 1083 01f8 0E94 0000 		call host_consumer_send
 1084               	.LVL107:
 1085 01fc 00C0      		rjmp .L85
 1086               	.L74:
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1087               		.loc 1 365 0
 1088 01fe 1123      		tst r17
 1089 0200 01F0      		breq .L108
 366:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1090               		.loc 1 366 0
 1091 0202 D53F      		cpi r29,lo8(-11)
 1092 0204 01F0      		breq .L110
 1093 0206 D63F      		cpi r29,lo8(-10)
 1094 0208 01F0      		breq .L111
 1095 020a D43F      		cpi r29,lo8(-12)
 1096 020c 01F4      		brne .L109
 368:./tmk_core/common/action.c ****                         break;
 1097               		.loc 1 368 0
 1098 020e 8091 0000 		lds r24,tp_buttons
 1099 0212 9091 0000 		lds r25,tp_buttons+1
 1100 0216 8160      		ori r24,1
 1101               	.L183:
 374:./tmk_core/common/action.c ****                         break;
 1102               		.loc 1 374 0
 1103 0218 9093 0000 		sts tp_buttons+1,r25
 1104 021c 8093 0000 		sts tp_buttons,r24
 1105               	.L109:
 379:./tmk_core/common/action.c ****                 mousekey_send();
 1106               		.loc 1 379 0
 1107 0220 8D2F      		mov r24,r29
 1108 0222 0E94 0000 		call mousekey_on
 1109               	.LVL108:
 1110               	.L191:
 396:./tmk_core/common/action.c ****             }
 1111               		.loc 1 396 0
 1112 0226 0E94 0000 		call mousekey_send
 1113               	.LVL109:
 1114 022a 00C0      		rjmp .L85
 1115               	.L110:
 371:./tmk_core/common/action.c ****                         break;
 1116               		.loc 1 371 0
 1117 022c 8091 0000 		lds r24,tp_buttons
 1118 0230 9091 0000 		lds r25,tp_buttons+1
 1119 0234 8260      		ori r24,2
 1120 0236 00C0      		rjmp .L183
 1121               	.L111:
 374:./tmk_core/common/action.c ****                         break;
 1122               		.loc 1 374 0
 1123 0238 8091 0000 		lds r24,tp_buttons
 1124 023c 9091 0000 		lds r25,tp_buttons+1
 1125 0240 8460      		ori r24,4
 1126 0242 00C0      		rjmp .L183
 1127               	.L108:
 382:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1128               		.loc 1 382 0
 1129 0244 D53F      		cpi r29,lo8(-11)
 1130 0246 01F0      		breq .L114
 1131 0248 D63F      		cpi r29,lo8(-10)
 1132 024a 01F0      		breq .L115
 1133 024c D43F      		cpi r29,lo8(-12)
 1134 024e 01F4      		brne .L113
 384:./tmk_core/common/action.c ****                         break;
 1135               		.loc 1 384 0
 1136 0250 8091 0000 		lds r24,tp_buttons
 1137 0254 9091 0000 		lds r25,tp_buttons+1
 1138 0258 8E7F      		andi r24,254
 1139               	.L184:
 390:./tmk_core/common/action.c ****                         break;
 1140               		.loc 1 390 0
 1141 025a 9093 0000 		sts tp_buttons+1,r25
 1142 025e 8093 0000 		sts tp_buttons,r24
 1143               	.L113:
 395:./tmk_core/common/action.c ****                 mousekey_send();
 1144               		.loc 1 395 0
 1145 0262 8D2F      		mov r24,r29
 1146 0264 0E94 0000 		call mousekey_off
 1147               	.LVL110:
 1148 0268 00C0      		rjmp .L191
 1149               	.L114:
 387:./tmk_core/common/action.c ****                         break;
 1150               		.loc 1 387 0
 1151 026a 8091 0000 		lds r24,tp_buttons
 1152 026e 9091 0000 		lds r25,tp_buttons+1
 1153 0272 8D7F      		andi r24,253
 1154 0274 00C0      		rjmp .L184
 1155               	.L115:
 390:./tmk_core/common/action.c ****                         break;
 1156               		.loc 1 390 0
 1157 0276 8091 0000 		lds r24,tp_buttons
 1158 027a 9091 0000 		lds r25,tp_buttons+1
 1159 027e 8B7F      		andi r24,251
 1160 0280 00C0      		rjmp .L184
 1161               	.L75:
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1162               		.loc 1 402 0
 1163 0282 8C2F      		mov r24,r28
 1164 0284 8370      		andi r24,lo8(3)
 1165 0286 01F0      		breq .+2
 1166 0288 00C0      		rjmp .L117
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1167               		.loc 1 404 0
 1168 028a 1111      		cpse r17,__zero_reg__
 1169 028c 00C0      		rjmp .L118
 1170               	.LVL111:
 1171               	.LBB25:
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1172               		.loc 1 405 0
 1173 028e 2D2F      		mov r18,r29
 1174 0290 2295      		swap r18
 1175 0292 2695      		lsr r18
 1176 0294 2770      		andi r18,lo8(7)
 1177 0296 220F      		lsl r18
 1178 0298 220F      		lsl r18
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1179               		.loc 1 406 0
 1180 029a 6D2F      		mov r22,r29
 1181 029c 6F70      		andi r22,lo8(15)
 1182 029e 862E      		mov r8,r22
 1183 02a0 912C      		mov r9,__zero_reg__
 1184 02a2 B12C      		mov r11,__zero_reg__
 1185 02a4 A12C      		mov r10,__zero_reg__
 1186 02a6 022E      		mov r0,r18
 1187 02a8 00C0      		rjmp 2f
 1188               		1:
 1189 02aa 880C      		lsl r8
 1190 02ac 991C      		rol r9
 1191 02ae AA1C      		rol r10
 1192 02b0 BB1C      		rol r11
 1193               		2:
 1194 02b2 0A94      		dec r0
 1195 02b4 02F4      		brpl 1b
 1196               	.LVL112:
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1197               		.loc 1 407 0
 1198 02b6 60E0      		ldi r22,0
 1199 02b8 70E0      		ldi r23,0
 1200 02ba CB01      		movw r24,r22
 1201 02bc D4FF      		sbrs r29,4
 1202 02be 00C0      		rjmp .L119
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1203               		.loc 1 407 0 is_stmt 0 discriminator 1
 1204 02c0 6FE0      		ldi r22,lo8(15)
 1205 02c2 70E0      		ldi r23,0
 1206 02c4 80E0      		ldi r24,0
 1207 02c6 90E0      		ldi r25,0
 1208 02c8 00C0      		rjmp 2f
 1209               		1:
 1210 02ca 660F      		lsl r22
 1211 02cc 771F      		rol r23
 1212 02ce 881F      		rol r24
 1213 02d0 991F      		rol r25
 1214               		2:
 1215 02d2 2A95      		dec r18
 1216 02d4 02F4      		brpl 1b
 1217 02d6 6095      		com r22
 1218 02d8 7095      		com r23
 1219 02da 8095      		com r24
 1220 02dc 9095      		com r25
 1221               	.L119:
 1222               	.LVL113:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1223               		.loc 1 408 0 is_stmt 1 discriminator 4
 1224 02de C695      		lsr r28
 1225 02e0 C695      		lsr r28
 1226               	.LVL114:
 1227 02e2 C370      		andi r28,lo8(3)
 1228 02e4 C230      		cpi r28,lo8(2)
 1229 02e6 01F0      		breq .L121
 1230 02e8 00F4      		brsh .L122
 1231 02ea 6829      		or r22,r8
 1232               	.LVL115:
 1233 02ec 7929      		or r23,r9
 1234 02ee 8A29      		or r24,r10
 1235 02f0 9B29      		or r25,r11
 1236 02f2 C130      		cpi r28,lo8(1)
 1237 02f4 01F0      		breq .L188
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1238               		.loc 1 409 0 discriminator 4
 1239 02f6 0E94 0000 		call default_layer_and
 1240               	.LVL116:
 1241               	.L118:
 1242               	.LBE25:
 647:./tmk_core/common/action.c ****             break;
 1243               		.loc 1 647 0
 1244 02fa 0E94 0000 		call host_keyboard_leds
 1245               	.LVL117:
 1246 02fe 0E94 0000 		call led_set
 1247               	.LVL118:
 648:./tmk_core/common/action.c ****         default:
 1248               		.loc 1 648 0
 1249 0302 00C0      		rjmp .L85
 1250               	.LVL119:
 1251               	.L121:
 1252               	.LBB26:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1253               		.loc 1 411 0
 1254 0304 6829      		or r22,r8
 1255               	.LVL120:
 1256 0306 7929      		or r23,r9
 1257 0308 8A29      		or r24,r10
 1258 030a 9B29      		or r25,r11
 1259 030c 0E94 0000 		call default_layer_xor
 1260               	.LVL121:
 1261 0310 00C0      		rjmp .L118
 1262               	.LVL122:
 1263               	.L122:
 412:./tmk_core/common/action.c ****                     }
 1264               		.loc 1 412 0
 1265 0312 0E94 0000 		call default_layer_and
 1266               	.LVL123:
 1267 0316 C501      		movw r24,r10
 1268 0318 B401      		movw r22,r8
 1269               	.L188:
 1270 031a 0E94 0000 		call default_layer_or
 1271               	.LVL124:
 1272 031e 00C0      		rjmp .L118
 1273               	.LVL125:
 1274               	.L117:
 1275               	.LBE26:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1276               		.loc 1 417 0
 1277 0320 8695      		lsr r24
 1278 0322 1123      		tst r17
 1279 0324 01F0      		breq .L125
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1280               		.loc 1 417 0 is_stmt 0 discriminator 1
 1281 0326 8C2F      		mov r24,r28
 1282 0328 8170      		andi r24,lo8(1)
 1283               	.L125:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1284               		.loc 1 417 0 discriminator 4
 1285 032a 8823      		tst r24
 1286 032c 01F0      		breq .L118
 1287               	.LVL126:
 1288               	.LBB27:
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1289               		.loc 1 419 0 is_stmt 1
 1290 032e 2D2F      		mov r18,r29
 1291 0330 2295      		swap r18
 1292 0332 2695      		lsr r18
 1293 0334 2770      		andi r18,lo8(7)
 1294 0336 220F      		lsl r18
 1295 0338 220F      		lsl r18
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1296               		.loc 1 420 0
 1297 033a 6D2F      		mov r22,r29
 1298 033c 6F70      		andi r22,lo8(15)
 1299 033e 862E      		mov r8,r22
 1300 0340 912C      		mov r9,__zero_reg__
 1301 0342 B12C      		mov r11,__zero_reg__
 1302 0344 A12C      		mov r10,__zero_reg__
 1303 0346 022E      		mov r0,r18
 1304 0348 00C0      		rjmp 2f
 1305               		1:
 1306 034a 880C      		lsl r8
 1307 034c 991C      		rol r9
 1308 034e AA1C      		rol r10
 1309 0350 BB1C      		rol r11
 1310               		2:
 1311 0352 0A94      		dec r0
 1312 0354 02F4      		brpl 1b
 1313               	.LVL127:
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1314               		.loc 1 421 0
 1315 0356 60E0      		ldi r22,0
 1316 0358 70E0      		ldi r23,0
 1317 035a CB01      		movw r24,r22
 1318 035c D4FF      		sbrs r29,4
 1319 035e 00C0      		rjmp .L126
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1320               		.loc 1 421 0 is_stmt 0 discriminator 1
 1321 0360 6FE0      		ldi r22,lo8(15)
 1322 0362 70E0      		ldi r23,0
 1323 0364 80E0      		ldi r24,0
 1324 0366 90E0      		ldi r25,0
 1325 0368 00C0      		rjmp 2f
 1326               		1:
 1327 036a 660F      		lsl r22
 1328 036c 771F      		rol r23
 1329 036e 881F      		rol r24
 1330 0370 991F      		rol r25
 1331               		2:
 1332 0372 2A95      		dec r18
 1333 0374 02F4      		brpl 1b
 1334 0376 6095      		com r22
 1335 0378 7095      		com r23
 1336 037a 8095      		com r24
 1337 037c 9095      		com r25
 1338               	.L126:
 1339               	.LVL128:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1340               		.loc 1 422 0 is_stmt 1 discriminator 4
 1341 037e C695      		lsr r28
 1342 0380 C695      		lsr r28
 1343               	.LVL129:
 1344 0382 C370      		andi r28,lo8(3)
 1345 0384 C230      		cpi r28,lo8(2)
 1346 0386 01F0      		breq .L128
 1347 0388 00F4      		brsh .L129
 1348 038a 6829      		or r22,r8
 1349               	.LVL130:
 1350 038c 7929      		or r23,r9
 1351 038e 8A29      		or r24,r10
 1352 0390 9B29      		or r25,r11
 1353 0392 C130      		cpi r28,lo8(1)
 1354 0394 01F0      		breq .L187
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1355               		.loc 1 423 0 discriminator 4
 1356 0396 0E94 0000 		call layer_and
 1357               	.LVL131:
 1358 039a 00C0      		rjmp .L118
 1359               	.LVL132:
 1360               	.L128:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1361               		.loc 1 425 0
 1362 039c 6829      		or r22,r8
 1363               	.LVL133:
 1364 039e 7929      		or r23,r9
 1365 03a0 8A29      		or r24,r10
 1366 03a2 9B29      		or r25,r11
 1367 03a4 0E94 0000 		call layer_xor
 1368               	.LVL134:
 1369 03a8 00C0      		rjmp .L118
 1370               	.LVL135:
 1371               	.L129:
 426:./tmk_core/common/action.c ****                     }
 1372               		.loc 1 426 0
 1373 03aa 0E94 0000 		call layer_and
 1374               	.LVL136:
 1375 03ae C501      		movw r24,r10
 1376 03b0 B401      		movw r22,r8
 1377               	.L187:
 1378 03b2 0E94 0000 		call layer_or
 1379               	.LVL137:
 1380 03b6 00C0      		rjmp .L118
 1381               	.LVL138:
 1382               	.L76:
 1383               	.LBE27:
 434:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1384               		.loc 1 434 0
 1385 03b8 E0E2      		ldi r30,lo8(32)
 1386 03ba ED0F      		add r30,r29
 1387 03bc E531      		cpi r30,lo8(21)
 1388 03be 00F0      		brlo .+2
 1389 03c0 00C0      		rjmp .L131
 1390 03c2 F0E0      		ldi r31,0
 1391 03c4 E050      		subi r30,lo8(-(gs(.L133)))
 1392 03c6 F040      		sbci r31,hi8(-(gs(.L133)))
 1393 03c8 0C94 0000 		jmp __tablejump2__
 1394               		.p2align	1
 1395               	.L133:
 1396 03cc 0000      		.word gs(.L132)
 1397 03ce 0000      		.word gs(.L132)
 1398 03d0 0000      		.word gs(.L132)
 1399 03d2 0000      		.word gs(.L132)
 1400 03d4 0000      		.word gs(.L132)
 1401 03d6 0000      		.word gs(.L132)
 1402 03d8 0000      		.word gs(.L132)
 1403 03da 0000      		.word gs(.L132)
 1404 03dc 0000      		.word gs(.L132)
 1405 03de 0000      		.word gs(.L132)
 1406 03e0 0000      		.word gs(.L132)
 1407 03e2 0000      		.word gs(.L132)
 1408 03e4 0000      		.word gs(.L132)
 1409 03e6 0000      		.word gs(.L132)
 1410 03e8 0000      		.word gs(.L132)
 1411 03ea 0000      		.word gs(.L132)
 1412 03ec 0000      		.word gs(.L134)
 1413 03ee 0000      		.word gs(.L135)
 1414 03f0 0000      		.word gs(.L136)
 1415 03f2 0000      		.word gs(.L137)
 1416 03f4 0000      		.word gs(.L138)
 1417               	.L132:
 1418 03f6 DF70      		andi r29,lo8(15)
 1419               	.LVL139:
 1420 03f8 8C2F      		mov r24,r28
 1421 03fa 8F71      		andi r24,lo8(31)
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1422               		.loc 1 437 0
 1423 03fc 1123      		tst r17
 1424 03fe 01F0      		breq .L139
 438:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1425               		.loc 1 438 0
 1426 0400 0E94 0000 		call layer_on
 1427               	.LVL140:
 439:./tmk_core/common/action.c ****                     } else {
 1428               		.loc 1 439 0
 1429 0404 8D2F      		mov r24,r29
 1430 0406 0E94 0000 		call register_mods
 1431               	.LVL141:
 1432 040a 00C0      		rjmp .L69
 1433               	.L139:
 441:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1434               		.loc 1 441 0
 1435 040c 0E94 0000 		call layer_off
 1436               	.LVL142:
 442:./tmk_core/common/action.c ****                     }
 1437               		.loc 1 442 0
 1438 0410 8D2F      		mov r24,r29
 1439 0412 0E94 0000 		call unregister_mods
 1440               	.LVL143:
 1441 0416 00C0      		rjmp .L69
 1442               	.LVL144:
 1443               	.L134:
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1444               		.loc 1 447 0
 1445 0418 1123      		tst r17
 1446 041a 01F0      		breq .L140
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1447               		.loc 1 448 0
 1448 041c 0530      		cpi r16,lo8(5)
 1449 041e 00F0      		brlo .+2
 1450 0420 00C0      		rjmp .L69
 1451               	.L141:
 449:./tmk_core/common/action.c ****                         }
 1452               		.loc 1 449 0
 1453 0422 8C2F      		mov r24,r28
 1454 0424 8F71      		andi r24,lo8(31)
 1455 0426 0E94 0000 		call layer_invert
 1456               	.LVL145:
 1457 042a 00C0      		rjmp .L69
 1458               	.L140:
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1459               		.loc 1 452 0
 1460 042c 0630      		cpi r16,lo8(6)
 1461 042e 00F0      		brlo .+2
 1462 0430 00C0      		rjmp .L69
 1463 0432 00C0      		rjmp .L141
 1464               	.L135:
 1465 0434 8C2F      		mov r24,r28
 1466 0436 8F71      		andi r24,lo8(31)
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1467               		.loc 1 458 0
 1468 0438 1123      		tst r17
 1469 043a 01F0      		breq .L185
 1470               	.L186:
 515:./tmk_core/common/action.c ****                         }
 1471               		.loc 1 515 0
 1472 043c 0E94 0000 		call layer_on
 1473               	.LVL146:
 1474 0440 00C0      		rjmp .L69
 1475               	.L136:
 1476 0442 8C2F      		mov r24,r28
 1477 0444 8F71      		andi r24,lo8(31)
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1478               		.loc 1 462 0
 1479 0446 1123      		tst r17
 1480 0448 01F0      		breq .L186
 1481               	.L185:
 526:./tmk_core/common/action.c ****                         }
 1482               		.loc 1 526 0
 1483 044a 0E94 0000 		call layer_off
 1484               	.LVL147:
 1485 044e 00C0      		rjmp .L69
 1486               	.L137:
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1487               		.loc 1 466 0
 1488 0450 1123      		tst r17
 1489 0452 01F0      		breq .L145
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1490               		.loc 1 466 0 is_stmt 0 discriminator 1
 1491 0454 8C2F      		mov r24,r28
 1492 0456 8F71      		andi r24,lo8(31)
 1493 0458 0E94 0000 		call layer_move
 1494               	.LVL148:
 1495 045c 00C0      		rjmp .L69
 1496               	.L145:
 467:./tmk_core/common/action.c ****                     break;
 1497               		.loc 1 467 0 is_stmt 1
 1498 045e 0E94 0000 		call layer_clear
 1499               	.LVL149:
 1500 0462 00C0      		rjmp .L69
 1501               	.L138:
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1502               		.loc 1 495 0
 1503 0464 1123      		tst r17
 1504 0466 01F0      		breq .L146
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1505               		.loc 1 496 0
 1506 0468 CF71      		andi r28,lo8(31)
 1507               	.LVL150:
 1508 046a 8C2F      		mov r24,r28
 1509 046c 0E94 0000 		call layer_on
 1510               	.LVL151:
 497:./tmk_core/common/action.c ****                     } else {
 1511               		.loc 1 497 0
 1512 0470 63E0      		ldi r22,lo8(3)
 1513 0472 8C2F      		mov r24,r28
 1514 0474 0E94 0000 		call set_oneshot_layer
 1515               	.LVL152:
 1516 0478 00C0      		rjmp .L69
 1517               	.LVL153:
 1518               	.L146:
 499:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1519               		.loc 1 499 0
 1520 047a 81E0      		ldi r24,lo8(1)
 1521 047c 0E94 0000 		call clear_oneshot_layer_state
 1522               	.LVL154:
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1523               		.loc 1 500 0
 1524 0480 0230      		cpi r16,lo8(2)
 1525 0482 00F4      		brsh .+2
 1526 0484 00C0      		rjmp .L69
 501:./tmk_core/common/action.c ****                         }
 1527               		.loc 1 501 0
 1528 0486 82E0      		ldi r24,lo8(2)
 1529 0488 0E94 0000 		call clear_oneshot_layer_state
 1530               	.LVL155:
 1531 048c 00C0      		rjmp .L69
 1532               	.L131:
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1533               		.loc 1 509 0
 1534 048e 1123      		tst r17
 1535 0490 01F0      		breq .L147
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1536               		.loc 1 510 0
 1537 0492 0023      		tst r16
 1538 0494 01F0      		breq .L148
 512:./tmk_core/common/action.c ****                         } else {
 1539               		.loc 1 512 0
 1540 0496 8D2F      		mov r24,r29
 1541 0498 0E94 0000 		call register_code
 1542               	.LVL156:
 1543 049c 00C0      		rjmp .L69
 1544               	.L148:
 515:./tmk_core/common/action.c ****                         }
 1545               		.loc 1 515 0
 1546 049e 8C2F      		mov r24,r28
 1547 04a0 8F71      		andi r24,lo8(31)
 1548 04a2 00C0      		rjmp .L186
 1549               	.L147:
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1550               		.loc 1 518 0
 1551 04a4 0023      		tst r16
 1552 04a6 01F0      		breq .L149
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1553               		.loc 1 520 0
 1554 04a8 D933      		cpi r29,lo8(57)
 1555 04aa 01F4      		brne .L150
 1556               	.LVL157:
 1557               	.LBB28:
 1558               	.LBB29:
 1559               		.loc 2 187 0
 1560 04ac FFEF      		ldi r31,lo8(255999)
 1561 04ae 27EE      		ldi r18,hi8(255999)
 1562 04b0 83E0      		ldi r24,hlo8(255999)
 1563 04b2 F150      	1:	subi r31,1
 1564 04b4 2040      		sbci r18,0
 1565 04b6 8040      		sbci r24,0
 1566 04b8 01F4      		brne 1b
 1567 04ba 00C0      		rjmp .
 1568 04bc 0000      		nop
 1569               	.LVL158:
 1570               	.L150:
 1571               	.LBE29:
 1572               	.LBE28:
 523:./tmk_core/common/action.c ****                         } else {
 1573               		.loc 1 523 0
 1574 04be 8D2F      		mov r24,r29
 1575 04c0 0E94 0000 		call unregister_code
 1576               	.LVL159:
 1577 04c4 00C0      		rjmp .L69
 1578               	.L149:
 526:./tmk_core/common/action.c ****                         }
 1579               		.loc 1 526 0
 1580 04c6 8C2F      		mov r24,r28
 1581 04c8 8F71      		andi r24,lo8(31)
 1582 04ca 00C0      		rjmp .L185
 1583               	.L77:
 537:./tmk_core/common/action.c ****             break;
 1584               		.loc 1 537 0
 1585 04cc 4C2F      		mov r20,r28
 1586 04ce 4F70      		andi r20,lo8(15)
 1587 04d0 6D2F      		mov r22,r29
 1588 04d2 C701      		movw r24,r14
 1589 04d4 0E94 0000 		call action_get_macro
 1590               	.LVL160:
 1591 04d8 0E94 0000 		call action_macro_play
 1592               	.LVL161:
 538:./tmk_core/common/action.c **** #endif
 1593               		.loc 1 538 0
 1594 04dc 00C0      		rjmp .L85
 1595               	.L78:
 632:./tmk_core/common/action.c ****             break;
 1596               		.loc 1 632 0
 1597 04de 4C2F      		mov r20,r28
 1598 04e0 4F70      		andi r20,lo8(15)
 1599 04e2 6D2F      		mov r22,r29
 1600 04e4 C701      		movw r24,r14
 1601 04e6 0E94 0000 		call action_function
 1602               	.LVL162:
 633:./tmk_core/common/action.c **** #endif
 1603               		.loc 1 633 0
 1604 04ea 00C0      		rjmp .L85
 1605               	.LVL163:
 1606               	.L66:
 1607               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1608               		.loc 1 691 0
 1609 04ec DF91      		pop r29
 1610               	.LVL164:
 1611 04ee CF91      		pop r28
 1612 04f0 1F91      		pop r17
 1613               	.LVL165:
 1614 04f2 0F91      		pop r16
 1615 04f4 FF90      		pop r15
 1616 04f6 EF90      		pop r14
 1617               	.LVL166:
 1618 04f8 DF90      		pop r13
 1619               	.LVL167:
 1620 04fa BF90      		pop r11
 1621 04fc AF90      		pop r10
 1622 04fe 9F90      		pop r9
 1623 0500 8F90      		pop r8
 1624 0502 0895      		ret
 1625               		.cfi_endproc
 1626               	.LFE18:
 1628               		.section	.text.process_record,"ax",@progbits
 1629               	.global	process_record
 1631               	process_record:
 1632               	.LFB17:
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1633               		.loc 1 173 0
 1634               		.cfi_startproc
 1635               	.LVL168:
 1636 0000 0F93      		push r16
 1637               	.LCFI16:
 1638               		.cfi_def_cfa_offset 3
 1639               		.cfi_offset 16, -2
 1640 0002 1F93      		push r17
 1641               	.LCFI17:
 1642               		.cfi_def_cfa_offset 4
 1643               		.cfi_offset 17, -3
 1644 0004 CF93      		push r28
 1645               	.LCFI18:
 1646               		.cfi_def_cfa_offset 5
 1647               		.cfi_offset 28, -4
 1648 0006 DF93      		push r29
 1649               	.LCFI19:
 1650               		.cfi_def_cfa_offset 6
 1651               		.cfi_offset 29, -5
 1652               	/* prologue: function */
 1653               	/* frame size = 0 */
 1654               	/* stack size = 4 */
 1655               	.L__stack_usage = 4
 1656 0008 EC01      		movw r28,r24
 1657 000a 9881      		ld r25,Y
 1658 000c 8981      		ldd r24,Y+1
 1659               	.LVL169:
 1660               	.LBB32:
 1661               	.LBB33:
 1662               		.file 3 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1663               		.loc 3 49 0
 1664 000e 2B81      		ldd r18,Y+3
 1665 0010 3C81      		ldd r19,Y+4
 1666 0012 232B      		or r18,r19
 1667 0014 01F0      		breq .L198
 1668 0016 8F3F      		cpi r24,lo8(-1)
 1669 0018 01F4      		brne .L199
 1670 001a 81E0      		ldi r24,lo8(1)
 1671 001c 9F3F      		cpi r25,lo8(-1)
 1672 001e 01F0      		breq .L195
 1673               	.L199:
 1674 0020 80E0      		ldi r24,0
 1675 0022 00C0      		rjmp .L195
 1676               	.L198:
 1677 0024 81E0      		ldi r24,lo8(1)
 1678               	.L195:
 1679               	.LBE33:
 1680               	.LBE32:
 174:./tmk_core/common/action.c **** 
 1681               		.loc 1 174 0
 1682 0026 80FD      		sbrc r24,0
 1683 0028 00C0      		rjmp .L194
 176:./tmk_core/common/action.c ****         return;
 1684               		.loc 1 176 0
 1685 002a CE01      		movw r24,r28
 1686 002c 0E94 0000 		call process_record_quantum
 1687               	.LVL170:
 1688 0030 8823      		tst r24
 1689 0032 01F0      		breq .L194
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1690               		.loc 1 179 0
 1691 0034 6881      		ld r22,Y
 1692 0036 7981      		ldd r23,Y+1
 1693 0038 8A81      		ldd r24,Y+2
 1694 003a 0E94 0000 		call store_or_get_action
 1695               	.LVL171:
 1696 003e 8C01      		movw r16,r24
 1697               	.LVL172:
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1698               		.loc 1 182 0
 1699 0040 0E94 0000 		call layer_debug
 1700               	.LVL173:
 183:./tmk_core/common/action.c **** #endif
 1701               		.loc 1 183 0
 1702 0044 0E94 0000 		call default_layer_debug
 1703               	.LVL174:
 187:./tmk_core/common/action.c **** }
 1704               		.loc 1 187 0
 1705 0048 B801      		movw r22,r16
 1706 004a CE01      		movw r24,r28
 1707               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 1708               		.loc 1 188 0
 1709 004c DF91      		pop r29
 1710 004e CF91      		pop r28
 1711               	.LVL175:
 1712 0050 1F91      		pop r17
 1713 0052 0F91      		pop r16
 1714               	.LVL176:
 187:./tmk_core/common/action.c **** }
 1715               		.loc 1 187 0
 1716 0054 0C94 0000 		jmp process_action
 1717               	.LVL177:
 1718               	.L194:
 1719               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 1720               		.loc 1 188 0
 1721 0058 DF91      		pop r29
 1722 005a CF91      		pop r28
 1723               	.LVL178:
 1724 005c 1F91      		pop r17
 1725 005e 0F91      		pop r16
 1726 0060 0895      		ret
 1727               		.cfi_endproc
 1728               	.LFE17:
 1730               		.section	.text.process_record_nocache,"ax",@progbits
 1731               	.global	process_record_nocache
 1733               	process_record_nocache:
 1734               	.LFB14:
 134:./tmk_core/common/action.c ****     process_record(record);
 1735               		.loc 1 134 0
 1736               		.cfi_startproc
 1737               	.LVL179:
 1738               	/* prologue: function */
 1739               	/* frame size = 0 */
 1740               	/* stack size = 0 */
 1741               	.L__stack_usage = 0
 135:./tmk_core/common/action.c **** }
 1742               		.loc 1 135 0
 1743 0000 0C94 0000 		jmp process_record
 1744               	.LVL180:
 1745               		.cfi_endproc
 1746               	.LFE14:
 1748               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1749               	.global	clear_keyboard_but_mods
 1751               	clear_keyboard_but_mods:
 1752               	.LFB24:
 860:./tmk_core/common/action.c **** 
 861:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:./tmk_core/common/action.c ****  *
 863:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:./tmk_core/common/action.c ****  */
 865:./tmk_core/common/action.c **** void clear_keyboard(void)
 866:./tmk_core/common/action.c **** {
 867:./tmk_core/common/action.c ****     clear_mods();
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:./tmk_core/common/action.c **** }
 870:./tmk_core/common/action.c **** 
 871:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:./tmk_core/common/action.c ****  *
 873:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:./tmk_core/common/action.c ****  */
 875:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:./tmk_core/common/action.c **** {
 1753               		.loc 1 876 0
 1754               		.cfi_startproc
 1755               	/* prologue: function */
 1756               	/* frame size = 0 */
 1757               	/* stack size = 0 */
 1758               	.L__stack_usage = 0
 877:./tmk_core/common/action.c ****     clear_weak_mods();
 1759               		.loc 1 877 0
 1760 0000 0E94 0000 		call clear_weak_mods
 1761               	.LVL181:
 878:./tmk_core/common/action.c ****     clear_macro_mods();
 1762               		.loc 1 878 0
 1763 0004 0E94 0000 		call clear_macro_mods
 1764               	.LVL182:
 879:./tmk_core/common/action.c ****     clear_keys();
 1765               		.loc 1 879 0
 1766 0008 0E94 0000 		call clear_keys
 1767               	.LVL183:
 880:./tmk_core/common/action.c ****     send_keyboard_report();
 1768               		.loc 1 880 0
 1769 000c 0E94 0000 		call send_keyboard_report
 1770               	.LVL184:
 881:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:./tmk_core/common/action.c ****     mousekey_clear();
 1771               		.loc 1 882 0
 1772 0010 0E94 0000 		call mousekey_clear
 1773               	.LVL185:
 883:./tmk_core/common/action.c ****     mousekey_send();
 1774               		.loc 1 883 0
 1775 0014 0E94 0000 		call mousekey_send
 1776               	.LVL186:
 884:./tmk_core/common/action.c **** #endif
 885:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:./tmk_core/common/action.c ****     host_system_send(0);
 1777               		.loc 1 886 0
 1778 0018 90E0      		ldi r25,0
 1779 001a 80E0      		ldi r24,0
 1780 001c 0E94 0000 		call host_system_send
 1781               	.LVL187:
 887:./tmk_core/common/action.c ****     host_consumer_send(0);
 1782               		.loc 1 887 0
 1783 0020 90E0      		ldi r25,0
 1784 0022 80E0      		ldi r24,0
 1785 0024 0C94 0000 		jmp host_consumer_send
 1786               	.LVL188:
 1787               		.cfi_endproc
 1788               	.LFE24:
 1790               		.section	.text.clear_keyboard,"ax",@progbits
 1791               	.global	clear_keyboard
 1793               	clear_keyboard:
 1794               	.LFB23:
 866:./tmk_core/common/action.c ****     clear_mods();
 1795               		.loc 1 866 0
 1796               		.cfi_startproc
 1797               	/* prologue: function */
 1798               	/* frame size = 0 */
 1799               	/* stack size = 0 */
 1800               	.L__stack_usage = 0
 867:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1801               		.loc 1 867 0
 1802 0000 0E94 0000 		call clear_mods
 1803               	.LVL189:
 868:./tmk_core/common/action.c **** }
 1804               		.loc 1 868 0
 1805 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1806               	.LVL190:
 1807               		.cfi_endproc
 1808               	.LFE23:
 1810               		.section	.text.is_tap_key,"ax",@progbits
 1811               	.global	is_tap_key
 1813               	is_tap_key:
 1814               	.LFB25:
 888:./tmk_core/common/action.c **** #endif
 889:./tmk_core/common/action.c **** }
 890:./tmk_core/common/action.c **** 
 891:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:./tmk_core/common/action.c ****  *
 893:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:./tmk_core/common/action.c ****  */
 895:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:./tmk_core/common/action.c **** {
 1815               		.loc 1 896 0
 1816               		.cfi_startproc
 1817               	.LVL191:
 1818               	/* prologue: function */
 1819               	/* frame size = 0 */
 1820               	/* stack size = 0 */
 1821               	.L__stack_usage = 0
 897:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1822               		.loc 1 897 0
 1823 0000 0E94 0000 		call layer_switch_get_action
 1824               	.LVL192:
 898:./tmk_core/common/action.c **** 
 899:./tmk_core/common/action.c ****     switch (action.kind.id) {
 1825               		.loc 1 899 0
 1826 0004 E92F      		mov r30,r25
 1827 0006 E295      		swap r30
 1828 0008 EF70      		andi r30,lo8(15)
 1829 000a E250      		subi r30,lo8(-(-2))
 1830 000c EE30      		cpi r30,lo8(14)
 1831 000e 00F4      		brsh .L218
 1832 0010 F0E0      		ldi r31,0
 1833 0012 E050      		subi r30,lo8(-(gs(.L212)))
 1834 0014 F040      		sbci r31,hi8(-(gs(.L212)))
 1835 0016 0C94 0000 		jmp __tablejump2__
 1836               		.p2align	1
 1837               	.L212:
 1838 001a 0000      		.word gs(.L211)
 1839 001c 0000      		.word gs(.L211)
 1840 001e 0000      		.word gs(.L218)
 1841 0020 0000      		.word gs(.L218)
 1842 0022 0000      		.word gs(.L213)
 1843 0024 0000      		.word gs(.L218)
 1844 0026 0000      		.word gs(.L218)
 1845 0028 0000      		.word gs(.L218)
 1846 002a 0000      		.word gs(.L211)
 1847 002c 0000      		.word gs(.L211)
 1848 002e 0000      		.word gs(.L214)
 1849 0030 0000      		.word gs(.L218)
 1850 0032 0000      		.word gs(.L218)
 1851 0034 0000      		.word gs(.L214)
 1852               	.L211:
 900:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1853               		.loc 1 904 0
 1854 0036 803F      		cpi r24,lo8(-16)
 1855 0038 01F0      		breq .L220
 1856 003a 00F4      		brsh .L216
 1857 003c 803E      		cpi r24,lo8(-32)
 1858 003e 00F4      		brsh .L218
 1859               	.L220:
 905:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:./tmk_core/common/action.c ****                     return true;
 1860               		.loc 1 908 0
 1861 0040 81E0      		ldi r24,lo8(1)
 1862               	.LVL193:
 1863               	/* epilogue start */
 909:./tmk_core/common/action.c ****             }
 910:./tmk_core/common/action.c ****             return false;
 911:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:./tmk_core/common/action.c ****             switch (action.swap.code) {
 913:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:./tmk_core/common/action.c ****                     return true;
 916:./tmk_core/common/action.c ****             }
 917:./tmk_core/common/action.c ****             return false;
 918:./tmk_core/common/action.c ****         case ACT_MACRO:
 919:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 921:./tmk_core/common/action.c ****             return false;
 922:./tmk_core/common/action.c ****     }
 923:./tmk_core/common/action.c ****     return false;
 924:./tmk_core/common/action.c **** }
 1864               		.loc 1 924 0
 1865 0042 0895      		ret
 1866               	.LVL194:
 1867               	.L216:
 904:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 1868               		.loc 1 904 0
 1869 0044 843F      		cpi r24,lo8(-12)
 1870 0046 01F0      		breq .L220
 1871               	.L218:
 910:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1872               		.loc 1 910 0
 1873 0048 80E0      		ldi r24,0
 1874               	.LVL195:
 1875 004a 0895      		ret
 1876               	.LVL196:
 1877               	.L213:
 912:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 1878               		.loc 1 912 0
 1879 004c 803E      		cpi r24,lo8(-32)
 1880 004e 00F0      		brlo .L220
 1881 0050 813F      		cpi r24,lo8(-15)
 1882 0052 01F4      		brne .L218
 1883 0054 00C0      		rjmp .L220
 1884               	.L214:
 920:./tmk_core/common/action.c ****             return false;
 1885               		.loc 1 920 0
 1886 0056 93FB      		bst r25,3
 1887 0058 8827      		clr r24
 1888 005a 80F9      		bld r24,0
 1889               	.LVL197:
 1890 005c 0895      		ret
 1891               		.cfi_endproc
 1892               	.LFE25:
 1894               		.section	.text.debug_event,"ax",@progbits
 1895               	.global	debug_event
 1897               	debug_event:
 1898               	.LFB26:
 925:./tmk_core/common/action.c **** 
 926:./tmk_core/common/action.c **** 
 927:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:./tmk_core/common/action.c ****  *
 929:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:./tmk_core/common/action.c ****  */
 931:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:./tmk_core/common/action.c **** {
 1899               		.loc 1 932 0
 1900               		.cfi_startproc
 1901 0000 CF93      		push r28
 1902               	.LCFI20:
 1903               		.cfi_def_cfa_offset 3
 1904               		.cfi_offset 28, -2
 1905 0002 DF93      		push r29
 1906               	.LCFI21:
 1907               		.cfi_def_cfa_offset 4
 1908               		.cfi_offset 29, -3
 1909 0004 00D0      		rcall .
 1910 0006 00D0      		rcall .
 1911 0008 1F92      		push __zero_reg__
 1912               	.LCFI22:
 1913               		.cfi_def_cfa_offset 9
 1914 000a CDB7      		in r28,__SP_L__
 1915 000c DEB7      		in r29,__SP_H__
 1916               	.LCFI23:
 1917               		.cfi_def_cfa_register 28
 1918               	/* prologue: function */
 1919               	/* frame size = 5 */
 1920               	/* stack size = 7 */
 1921               	.L__stack_usage = 7
 1922               	/* epilogue start */
 933:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 934:./tmk_core/common/action.c **** }
 1923               		.loc 1 934 0
 1924 000e 0F90      		pop __tmp_reg__
 1925 0010 0F90      		pop __tmp_reg__
 1926 0012 0F90      		pop __tmp_reg__
 1927 0014 0F90      		pop __tmp_reg__
 1928 0016 0F90      		pop __tmp_reg__
 1929 0018 DF91      		pop r29
 1930 001a CF91      		pop r28
 1931 001c 0895      		ret
 1932               		.cfi_endproc
 1933               	.LFE26:
 1935               		.section	.text.debug_record,"ax",@progbits
 1936               	.global	debug_record
 1938               	debug_record:
 1939               	.LFB27:
 935:./tmk_core/common/action.c **** 
 936:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:./tmk_core/common/action.c ****  *
 938:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:./tmk_core/common/action.c ****  */
 940:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:./tmk_core/common/action.c **** {
 1940               		.loc 1 941 0
 1941               		.cfi_startproc
 1942 0000 CF93      		push r28
 1943               	.LCFI24:
 1944               		.cfi_def_cfa_offset 3
 1945               		.cfi_offset 28, -2
 1946 0002 DF93      		push r29
 1947               	.LCFI25:
 1948               		.cfi_def_cfa_offset 4
 1949               		.cfi_offset 29, -3
 1950 0004 00D0      		rcall .
 1951 0006 00D0      		rcall .
 1952 0008 00D0      		rcall .
 1953               	.LCFI26:
 1954               		.cfi_def_cfa_offset 10
 1955 000a CDB7      		in r28,__SP_L__
 1956 000c DEB7      		in r29,__SP_H__
 1957               	.LCFI27:
 1958               		.cfi_def_cfa_register 28
 1959               	/* prologue: function */
 1960               	/* frame size = 6 */
 1961               	/* stack size = 8 */
 1962               	.L__stack_usage = 8
 1963               	/* epilogue start */
 942:./tmk_core/common/action.c ****     debug_event(record.event);
 943:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 945:./tmk_core/common/action.c **** #endif
 946:./tmk_core/common/action.c **** }
 1964               		.loc 1 946 0
 1965 000e 2696      		adiw r28,6
 1966 0010 0FB6      		in __tmp_reg__,__SREG__
 1967 0012 F894      		cli
 1968 0014 DEBF      		out __SP_H__,r29
 1969 0016 0FBE      		out __SREG__,__tmp_reg__
 1970 0018 CDBF      		out __SP_L__,r28
 1971 001a DF91      		pop r29
 1972 001c CF91      		pop r28
 1973 001e 0895      		ret
 1974               		.cfi_endproc
 1975               	.LFE27:
 1977               		.section	.text.debug_action,"ax",@progbits
 1978               	.global	debug_action
 1980               	debug_action:
 1981               	.LFB28:
 947:./tmk_core/common/action.c **** 
 948:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:./tmk_core/common/action.c ****  *
 950:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:./tmk_core/common/action.c ****  */
 952:./tmk_core/common/action.c **** void debug_action(action_t action)
 953:./tmk_core/common/action.c **** {
 1982               		.loc 1 953 0
 1983               		.cfi_startproc
 1984               	.LVL198:
 1985               	/* prologue: function */
 1986               	/* frame size = 0 */
 1987               	/* stack size = 0 */
 1988               	.L__stack_usage = 0
 1989               	/* epilogue start */
 954:./tmk_core/common/action.c ****     switch (action.kind.id) {
 955:./tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
 956:./tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
 957:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
 958:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
 959:./tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
 960:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
 961:./tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
 962:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
 963:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
 964:./tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
 965:./tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
 966:./tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
 967:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
 968:./tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
 969:./tmk_core/common/action.c ****     }
 970:./tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 971:./tmk_core/common/action.c **** }
 1990               		.loc 1 971 0
 1991 0000 0895      		ret
 1992               		.cfi_endproc
 1993               	.LFE28:
 1995               		.comm	tp_buttons,2,1
 1996               		.text
 1997               	.Letext0:
 1998               		.file 4 "/usr/avr/include/stdint.h"
 1999               		.file 5 "./tmk_core/common/keycode.h"
 2000               		.file 6 "./tmk_core/common/report.h"
 2001               		.file 7 "./tmk_core/common/host.h"
 2002               		.file 8 "./tmk_core/common/mousekey.h"
 2003               		.file 9 "./tmk_core/common/command.h"
 2004               		.file 10 "./tmk_core/common/action_code.h"
 2005               		.file 11 "./tmk_core/common/action.h"
 2006               		.file 12 "./tmk_core/common/action_layer.h"
 2007               		.file 13 "./tmk_core/common/action_util.h"
 2008               		.file 14 "./tmk_core/common/avr/xprintf.h"
 2009               		.file 15 "./tmk_core/common/debug.h"
 2010               		.file 16 "./tmk_core/common/led.h"
 2011               		.file 17 "./tmk_core/common/action_macro.h"
 2012               		.file 18 "./tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
 /var/tmp/cc1DNlCs.s:2      *ABS*:000000000000003e __SP_H__
 /var/tmp/cc1DNlCs.s:3      *ABS*:000000000000003d __SP_L__
 /var/tmp/cc1DNlCs.s:4      *ABS*:000000000000003f __SREG__
 /var/tmp/cc1DNlCs.s:5      *ABS*:0000000000000000 __tmp_reg__
 /var/tmp/cc1DNlCs.s:6      *ABS*:0000000000000001 __zero_reg__
 /var/tmp/cc1DNlCs.s:13     .text.action_exec:0000000000000000 action_exec
 /var/tmp/cc1DNlCs.s:89     .text.process_record_quantum:0000000000000000 process_record_quantum
 /var/tmp/cc1DNlCs.s:109    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
 /var/tmp/cc1DNlCs.s:131    .text.register_code:0000000000000000 register_code
 /var/tmp/cc1DNlCs.s:468    .text.unregister_code:0000000000000000 unregister_code
 /var/tmp/cc1DNlCs.s:606    .text.register_mods:0000000000000000 register_mods
 /var/tmp/cc1DNlCs.s:634    .text.unregister_mods:0000000000000000 unregister_mods
 /var/tmp/cc1DNlCs.s:662    .text.process_action:0000000000000000 process_action
 /var/tmp/cc1DNlCs.s:1631   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
 /var/tmp/cc1DNlCs.s:1733   .text.process_record_nocache:0000000000000000 process_record_nocache
 /var/tmp/cc1DNlCs.s:1751   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
 /var/tmp/cc1DNlCs.s:1793   .text.clear_keyboard:0000000000000000 clear_keyboard
 /var/tmp/cc1DNlCs.s:1813   .text.is_tap_key:0000000000000000 is_tap_key
 /var/tmp/cc1DNlCs.s:1897   .text.debug_event:0000000000000000 debug_event
 /var/tmp/cc1DNlCs.s:1938   .text.debug_record:0000000000000000 debug_record
 /var/tmp/cc1DNlCs.s:1980   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_send
mousekey_off
default_layer_and
led_set
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
mousekey_clear
clear_mods
__do_clear_bss
